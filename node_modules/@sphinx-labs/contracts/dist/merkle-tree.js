"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeSphinxMerkleTree = exports.makeSphinxMerkleTreeFromLeaves = exports.isNetworkCancellationData = exports.isNetworkDeploymentData = exports.isBaseNetworkData = exports.makeSphinxLeaves = exports.Operation = exports.SphinxLeafType = void 0;
const merkle_tree_1 = require("@openzeppelin/merkle-tree");
const ethers_1 = require("ethers");
var SphinxLeafType;
(function (SphinxLeafType) {
    SphinxLeafType[SphinxLeafType["APPROVE"] = 0] = "APPROVE";
    SphinxLeafType[SphinxLeafType["EXECUTE"] = 1] = "EXECUTE";
    SphinxLeafType[SphinxLeafType["CANCEL"] = 2] = "CANCEL";
})(SphinxLeafType = exports.SphinxLeafType || (exports.SphinxLeafType = {}));
var Operation;
(function (Operation) {
    Operation[Operation["Call"] = 0] = "Call";
    Operation[Operation["DelegateCall"] = 1] = "DelegateCall";
})(Operation = exports.Operation || (exports.Operation = {}));
const makeSphinxLeaves = (deploymentData) => {
    let approvalIncluded = false;
    let arbitraryApprovalIncluded = false;
    let cancellationLeafIncluded = false;
    const merkleLeaves = [];
    const coder = ethers_1.AbiCoder.defaultAbiCoder();
    for (const [chainIdStr, data] of Object.entries(deploymentData)) {
        if ((0, exports.isNetworkDeploymentData)(data) && !(0, exports.isNetworkCancellationData)(data)) {
            const chainId = data.arbitraryChain ? BigInt(0) : BigInt(chainIdStr);
            if (data.arbitraryChain) {
                if (cancellationLeafIncluded) {
                    throw new Error('Detected conflicting cancellation and `arbitraryChain` === true `DeploymentData` entries.');
                }
                else if (arbitraryApprovalIncluded) {
                    throw new Error('Detected `arbitraryChain` === true in multiple DeploymentData entries');
                }
                else if (approvalIncluded) {
                    throw new Error('Detected conflicting approval and `arbitraryChain` === true `DeploymentData` entries.');
                }
                arbitraryApprovalIncluded = true;
            }
            else if (arbitraryApprovalIncluded) {
                throw new Error('Detected conflicting approval and `arbitraryChain` === true `DeploymentData` entries.');
            }
            approvalIncluded = true;
            const approvalData = coder.encode([
                'address',
                'address',
                'uint256',
                'uint256',
                'address',
                'string',
                'bool',
            ], [
                data.safeProxy,
                data.moduleProxy,
                data.nonce,
                data.txs.length + 1,
                data.executor,
                data.uri,
                data.arbitraryChain,
            ]);
            merkleLeaves.push({
                chainId,
                index: BigInt(0),
                leafType: SphinxLeafType.APPROVE,
                data: approvalData,
            });
            let index = BigInt(1);
            for (const tx of data.txs) {
                const transactionLeafData = coder.encode(['address', 'uint256', 'uint256', 'bytes', 'uint256', 'bool'], [
                    tx.to,
                    BigInt(tx.value),
                    BigInt(tx.gas),
                    tx.txData,
                    BigInt(tx.operation),
                    tx.requireSuccess,
                ]);
                merkleLeaves.push({
                    chainId,
                    index,
                    leafType: SphinxLeafType.EXECUTE,
                    data: transactionLeafData,
                });
                index += BigInt(1);
            }
        }
        else if ((0, exports.isNetworkCancellationData)(data) &&
            !(0, exports.isNetworkDeploymentData)(data)) {
            const cancellationData = coder.encode(['address', 'address', 'uint256', 'bytes32', 'address', 'string'], [
                data.safeProxy,
                data.moduleProxy,
                data.nonce,
                data.merkleRootToCancel,
                data.executor,
                data.uri,
            ]);
            if (arbitraryApprovalIncluded) {
                throw new Error('Detected conflicting cancellation and `arbitraryChain` === true `DeploymentData` entries.');
            }
            else {
                cancellationLeafIncluded = true;
            }
            merkleLeaves.push({
                chainId: BigInt(chainIdStr),
                index: BigInt(0),
                leafType: SphinxLeafType.CANCEL,
                data: cancellationData,
            });
        }
        else {
            throw new Error(`Unknown network data type. Should never happen.`);
        }
    }
    return merkleLeaves;
};
exports.makeSphinxLeaves = makeSphinxLeaves;
const isBaseNetworkData = (networkData) => {
    return (typeof networkData.nonce === 'string' &&
        typeof networkData.executor === 'string' &&
        typeof networkData.safeProxy === 'string' &&
        typeof networkData.moduleProxy === 'string' &&
        typeof networkData.uri === 'string');
};
exports.isBaseNetworkData = isBaseNetworkData;
const isNetworkDeploymentData = (networkData) => {
    const networkDeploymentData = networkData;
    return ((0, exports.isBaseNetworkData)(networkData) &&
        typeof networkDeploymentData.arbitraryChain === 'boolean' &&
        Array.isArray(networkDeploymentData.txs) &&
        networkDeploymentData.txs.every((tx) => typeof tx.gas === 'string' &&
            typeof tx.operation === 'number' &&
            typeof tx.requireSuccess === 'boolean' &&
            typeof tx.to === 'string' &&
            typeof tx.txData === 'string' &&
            typeof tx.value === 'string'));
};
exports.isNetworkDeploymentData = isNetworkDeploymentData;
const isNetworkCancellationData = (networkData) => {
    const networkCancellationData = networkData;
    return ((0, exports.isBaseNetworkData)(networkData) &&
        typeof networkCancellationData.merkleRootToCancel === 'string');
};
exports.isNetworkCancellationData = isNetworkCancellationData;
const makeSphinxMerkleTreeFromLeaves = (leaves) => {
    const rawLeafArray = leaves.map((leaf) => [Object.values(leaf)]);
    const tree = merkle_tree_1.StandardMerkleTree.of(rawLeafArray, [
        'tuple(uint256, uint256, uint8, bytes)',
    ]);
    return {
        root: tree.root,
        leavesWithProofs: leaves.map((leaf) => {
            const leafWithProof = {
                leaf,
                proof: tree.getProof([Object.values(leaf)]),
            };
            return leafWithProof;
        }),
    };
};
exports.makeSphinxMerkleTreeFromLeaves = makeSphinxMerkleTreeFromLeaves;
const makeSphinxMerkleTree = (deploymentData) => {
    const leaves = (0, exports.makeSphinxLeaves)(deploymentData);
    return (0, exports.makeSphinxMerkleTreeFromLeaves)(leaves);
};
exports.makeSphinxMerkleTree = makeSphinxMerkleTree;
//# sourceMappingURL=merkle-tree.js.map