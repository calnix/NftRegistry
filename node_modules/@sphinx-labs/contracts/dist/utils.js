"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCurrentGitCommitHash = exports.isNonNullObject = exports.isLinkReferences = exports.recursivelyConvertResult = exports.add0x = exports.remove0x = exports.isContractArtifact = exports.parseFoundryContractArtifact = exports.decodeExecuteLeafData = exports.decodeApproveLeafData = void 0;
const child_process_1 = require("child_process");
const ethers_1 = require("ethers");
const decodeApproveLeafData = (leaf) => {
    const [safeProxy, moduleProxy, merkleRootNonce, numLeaves, executor, uri, arbitraryChain,] = ethers_1.AbiCoder.defaultAbiCoder().decode(['address', 'address', 'uint', 'uint', 'address', 'string', 'bool'], leaf.data);
    return {
        safeProxy,
        moduleProxy,
        merkleRootNonce,
        numLeaves,
        executor,
        uri,
        arbitraryChain,
    };
};
exports.decodeApproveLeafData = decodeApproveLeafData;
const decodeExecuteLeafData = (leaf) => {
    const [to, value, gas, txData, operation, requireSuccess] = ethers_1.AbiCoder.defaultAbiCoder().decode(['address', 'uint', 'uint', 'bytes', 'uint', 'bool'], leaf.data);
    return {
        to,
        value,
        gas,
        txData,
        operation,
        requireSuccess,
    };
};
exports.decodeExecuteLeafData = decodeExecuteLeafData;
const parseFoundryContractArtifact = (foundryArtifact) => {
    const abi = foundryArtifact.abi;
    const bytecode = (0, exports.add0x)(foundryArtifact.bytecode.object);
    const deployedBytecode = (0, exports.add0x)(foundryArtifact.deployedBytecode.object);
    const compilationTarget = foundryArtifact.metadata.settings.compilationTarget;
    const sourceName = Object.keys(compilationTarget)[0];
    const contractName = compilationTarget[sourceName];
    const metadata = foundryArtifact.metadata;
    const artifact = {
        abi,
        bytecode,
        sourceName,
        contractName,
        deployedBytecode,
        metadata,
        methodIdentifiers: foundryArtifact.methodIdentifiers,
        storageLayout: foundryArtifact.storageLayout,
        linkReferences: foundryArtifact.bytecode.linkReferences,
        deployedLinkReferences: foundryArtifact.deployedBytecode.linkReferences,
    };
    if (!(0, exports.isContractArtifact)(artifact)) {
        throw new Error(`Could not parse Foundry contract artifact.`);
    }
    return artifact;
};
exports.parseFoundryContractArtifact = parseFoundryContractArtifact;
const isContractArtifact = (obj) => {
    return (obj !== null &&
        typeof obj === 'object' &&
        Array.isArray(obj.abi) &&
        typeof obj.sourceName === 'string' &&
        typeof obj.contractName === 'string' &&
        typeof obj.bytecode === 'string' &&
        typeof obj.deployedBytecode === 'string' &&
        (0, exports.isLinkReferences)(obj.linkReferences) &&
        (0, exports.isLinkReferences)(obj.deployedLinkReferences) &&
        (0, exports.isNonNullObject)(obj.metadata) &&
        (obj.storageLayout === undefined ||
            isValidStorageLayout(obj.storageLayout)) &&
        ((0, exports.isNonNullObject)(obj.methodIdentifiers) ||
            obj.methodIdentifiers === undefined));
};
exports.isContractArtifact = isContractArtifact;
const remove0x = (str) => {
    if (str === undefined) {
        return str;
    }
    return str.startsWith('0x') ? str.slice(2) : str;
};
exports.remove0x = remove0x;
const add0x = (str) => {
    if (str === undefined) {
        return str;
    }
    return str.startsWith('0x') ? str : '0x' + str;
};
exports.add0x = add0x;
const recursivelyConvertResult = (types, values) => {
    const containsUnnamedValue = types.some((t) => t.name === '');
    const converted = containsUnnamedValue
        ? []
        : {};
    for (let i = 0; i < types.length; i++) {
        const paramType = types[i];
        const value = typeof values[i] === 'bigint' ? values[i].toString() : values[i];
        if (paramType.isTuple()) {
            const convertedTuple = (0, exports.recursivelyConvertResult)(paramType.components, value);
            if (containsUnnamedValue) {
                converted.push(convertedTuple);
            }
            else {
                converted[paramType.name] = convertedTuple;
            }
        }
        else if (paramType.isArray()) {
            const convertedElements = value.map((e) => {
                if (paramType.arrayChildren.isTuple()) {
                    const elementResult = ethers_1.ethers.Result.fromItems(e);
                    return (0, exports.recursivelyConvertResult)(paramType.arrayChildren.components, elementResult);
                }
                else if (paramType.arrayChildren.isArray()) {
                    const elementResult = ethers_1.ethers.Result.fromItems(e);
                    return (0, exports.recursivelyConvertResult)(Array(e.length).fill(paramType.arrayChildren.arrayChildren), elementResult);
                }
                else {
                    return typeof e === 'bigint' ? e.toString() : e;
                }
            });
            if (containsUnnamedValue) {
                converted.push(convertedElements);
            }
            else {
                converted[paramType.name] = convertedElements;
            }
        }
        else if (containsUnnamedValue) {
            converted.push(value);
        }
        else {
            converted[paramType.name] = value;
        }
    }
    return converted;
};
exports.recursivelyConvertResult = recursivelyConvertResult;
const isLinkReferences = (obj) => {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    return Object.values(obj).every((libraryFileNameObj) => {
        if (typeof libraryFileNameObj !== 'object' || libraryFileNameObj === null) {
            return false;
        }
        return Object.values(libraryFileNameObj).every((library) => Array.isArray(library) &&
            library.every((ref) => ref !== null &&
                typeof ref === 'object' &&
                typeof ref.length === 'number' &&
                typeof ref.start === 'number'));
    });
};
exports.isLinkReferences = isLinkReferences;
const isValidStorageLayout = (storageLayout) => {
    return (storageLayout !== null &&
        typeof storageLayout === 'object' &&
        Array.isArray(storageLayout.storage) &&
        typeof storageLayout.types === 'object');
};
const isNonNullObject = (obj) => {
    return typeof obj === 'object' && obj !== null;
};
exports.isNonNullObject = isNonNullObject;
const getCurrentGitCommitHash = () => {
    let commitHash;
    try {
        commitHash = (0, child_process_1.execSync)('git rev-parse HEAD 2>/dev/null').toString().trim();
    }
    catch {
        return null;
    }
    if (commitHash.length !== 40) {
        throw new Error(`Git commit hash is an unexpected length: ${commitHash}`);
    }
    return commitHash;
};
exports.getCurrentGitCommitHash = getCurrentGitCommitHash;
//# sourceMappingURL=utils.js.map