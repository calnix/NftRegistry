"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeFunctionCallDecodedAction = exports.makeContractDecodedAction = exports.makeNetworkConfig = exports.decodeDeploymentInfo = void 0;
const core_1 = require("@sphinx-labs/core");
const ethers_1 = require("ethers");
const contracts_1 = require("@sphinx-labs/contracts");
const utils_1 = require("./utils");
const decodeDeploymentInfo = (serializedDeploymentInfo, sphinxPluginTypesInterface, blockNumber) => {
    const parsed = JSON.parse(serializedDeploymentInfo);
    const parsedAccountAccessFragment = (0, utils_1.findFunctionFragment)(sphinxPluginTypesInterface, 'parsedAccountAccessType');
    const deployedContractSizesFragment = (0, utils_1.findFunctionFragment)(sphinxPluginTypesInterface, 'deployedContractSizesType');
    const coder = ethers_1.AbiCoder.defaultAbiCoder();
    const { safeAddress, moduleAddress, executorAddress, initialState, requireSuccess, safeInitData, arbitraryChain, sphinxLibraryVersion, } = parsed;
    const blockGasLimit = abiDecodeUint256(parsed.blockGasLimit);
    const chainId = abiDecodeUint256(parsed.chainId);
    const executionMode = abiDecodeUint256(parsed.executionMode);
    const nonce = abiDecodeUint256(parsed.nonce);
    const fundsRequestedForSafe = abiDecodeUint256(parsed.fundsRequestedForSafe);
    const safeStartingBalance = abiDecodeUint256(parsed.safeStartingBalance);
    const gasEstimates = abiDecodeUint256Array(parsed.gasEstimates);
    const deployedContractSizesResult = coder.decode(deployedContractSizesFragment.outputs, parsed.encodedDeployedContractSizes);
    const { deployedContractSizes } = (0, contracts_1.recursivelyConvertResult)(deployedContractSizesFragment.outputs, deployedContractSizesResult);
    const accountAccesses = parsed.encodedAccountAccesses.map((encoded) => {
        const decodedResult = coder.decode(parsedAccountAccessFragment.outputs, encoded);
        const { parsedAccountAccess } = (0, contracts_1.recursivelyConvertResult)(parsedAccountAccessFragment.outputs, decodedResult);
        return parsedAccountAccess;
    });
    const deploymentInfo = {
        safeAddress,
        moduleAddress,
        safeInitData,
        executorAddress,
        requireSuccess,
        nonce,
        chainId,
        blockGasLimit,
        blockNumber: blockNumber.toString(),
        initialState: {
            ...initialState,
        },
        executionMode: Number(executionMode),
        newConfig: {
            projectName: abiDecodeString(parsed.newConfig.projectName),
            orgId: abiDecodeString(parsed.newConfig.orgId),
            owners: parsed.newConfig.owners,
            mainnets: parsed.newConfig.mainnets,
            testnets: parsed.newConfig.testnets,
            threshold: abiDecodeUint256(parsed.newConfig.threshold),
            saltNonce: abiDecodeUint256(parsed.newConfig.saltNonce),
        },
        arbitraryChain,
        sphinxLibraryVersion: abiDecodeString(sphinxLibraryVersion),
        accountAccesses,
        gasEstimates,
        deployedContractSizes,
        fundsRequestedForSafe,
        safeStartingBalance,
    };
    if (!(0, utils_1.isDeploymentInfo)(deploymentInfo)) {
        throw new Error(`Invalid DeploymentInfo object. Should never happen.`);
    }
    (0, core_1.assertValidProjectName)(deploymentInfo.newConfig.projectName);
    return deploymentInfo;
};
exports.decodeDeploymentInfo = decodeDeploymentInfo;
const makeNetworkConfig = (deploymentInfo, isSystemDeployed, configArtifacts, libraries) => {
    const { safeAddress, moduleAddress, nonce, chainId, blockGasLimit, blockNumber, newConfig, executionMode, initialState, safeInitData, arbitraryChain, requireSuccess, accountAccesses, gasEstimates, deployedContractSizes, fundsRequestedForSafe, safeStartingBalance, } = deploymentInfo;
    const parsedActionInputs = [];
    const unlabeledContracts = [];
    for (let i = 0; i < accountAccesses.length; i++) {
        const { root, nested } = accountAccesses[i];
        const gas = (0, core_1.calculateMerkleLeafGas)(BigInt(chainId), gasEstimates[i].toString(), deployedContractSizes, accountAccesses[i]);
        const { parsedContracts, unlabeled } = (0, utils_1.parseNestedContractDeployments)(nested, configArtifacts);
        unlabeledContracts.push(...unlabeled);
        const executeActionIndex = i + 1;
        let actionInput;
        if (root.kind === contracts_1.AccountAccessKind.Create) {
            const initCodeWithArgs = root.data;
            const address = root.account;
            const fullyQualifiedName = (0, utils_1.findFullyQualifiedNameForInitCode)(initCodeWithArgs, configArtifacts);
            const decodedAction = (0, exports.makeContractDecodedAction)(address, initCodeWithArgs, configArtifacts, fullyQualifiedName, root.value);
            if (fullyQualifiedName) {
                parsedContracts.push({
                    address,
                    fullyQualifiedName,
                    initCodeWithArgs,
                });
            }
            else {
                unlabeledContracts.push({
                    address,
                    initCodeWithArgs,
                });
            }
            const action = {
                actionType: core_1.ActionInputType.CREATE,
                contractAddress: address,
                initCodeWithArgs,
                contracts: parsedContracts,
                index: executeActionIndex.toString(),
                decodedAction,
                gas,
                requireSuccess,
                value: '0',
                operation: contracts_1.Operation.DelegateCall,
                to: (0, contracts_1.getCreateCallAddress)(),
                txData: (0, core_1.encodeCreateCall)(root.value, initCodeWithArgs),
            };
            actionInput = action;
        }
        else if ((0, utils_1.isCreate2AccountAccess)(root, nested)) {
            const { create2Address, initCodeWithArgs } = (0, core_1.decodeDeterministicDeploymentProxyData)(root.data);
            const fullyQualifiedName = (0, utils_1.findFullyQualifiedNameForInitCode)(initCodeWithArgs, configArtifacts);
            const decodedAction = (0, exports.makeContractDecodedAction)(create2Address, initCodeWithArgs, configArtifacts, fullyQualifiedName, root.value);
            const action = {
                actionType: core_1.ActionInputType.CREATE2,
                create2Address,
                initCodeWithArgs,
                contracts: parsedContracts,
                index: executeActionIndex.toString(),
                decodedAction,
                gas,
                requireSuccess,
                value: root.value.toString(),
                operation: contracts_1.Operation.Call,
                to: contracts_1.DETERMINISTIC_DEPLOYMENT_PROXY_ADDRESS,
                txData: root.data,
            };
            actionInput = action;
        }
        else if (root.kind === contracts_1.AccountAccessKind.Call) {
            const to = root.account;
            const fullyQualifiedName = (0, utils_1.findFullyQualifiedNameForAddress)(to, accountAccesses, configArtifacts);
            const decodedAction = (0, exports.makeFunctionCallDecodedAction)(to, root.data, root.value.toString(), configArtifacts, fullyQualifiedName);
            const callInput = {
                actionType: core_1.ActionInputType.CALL,
                contracts: parsedContracts,
                index: executeActionIndex.toString(),
                decodedAction,
                gas,
                requireSuccess,
                value: root.value.toString(),
                operation: contracts_1.Operation.Call,
                to,
                txData: root.data,
            };
            actionInput = callInput;
        }
        else {
            throw new Error(`Invalid action input. Should never happen.`);
        }
        parsedActionInputs.push(actionInput);
        const maxGasLimit = (0, core_1.getMaxGasLimit)(BigInt(blockGasLimit), BigInt(chainId));
        if (BigInt(gas) > maxGasLimit) {
            const networkName = (0, core_1.fetchNameForNetwork)(BigInt(chainId));
            const { referenceName, address, functionName, variables, value } = actionInput.decodedAction;
            throw new Error(`Estimated gas for the following transaction is too high to be executed by Sphinx on ${networkName}:\n` +
                (0, core_1.prettyFunctionCall)(referenceName, address, functionName, variables, chainId, value, 5, 3));
        }
    }
    if (parsedActionInputs.length !== gasEstimates.length) {
        throw new Error(`Parsed action input array length (${parsedActionInputs.length}) does not equal gas\n` +
            `estimates array length (${gasEstimates.length}). Should never happen.`);
    }
    const networkConfig = {
        safeAddress,
        moduleAddress,
        safeInitData,
        nonce,
        chainId,
        blockGasLimit,
        blockNumber,
        newConfig,
        executionMode,
        initialState,
        isSystemDeployed,
        actionInputs: parsedActionInputs,
        unlabeledContracts,
        arbitraryChain,
        executorAddress: deploymentInfo.executorAddress,
        libraries: (0, utils_1.convertLibraryFormat)(libraries),
        gitCommit: (0, contracts_1.getCurrentGitCommitHash)(),
        safeFundingRequest: {
            fundsRequested: fundsRequestedForSafe,
            startingBalance: safeStartingBalance,
        },
    };
    return networkConfig;
};
exports.makeNetworkConfig = makeNetworkConfig;
const makeContractDecodedAction = (contractAddress, initCodeWithArgs, configArtifacts, fullyQualifiedName, value) => {
    if (fullyQualifiedName) {
        const coder = ethers_1.ethers.AbiCoder.defaultAbiCoder();
        const { artifact } = configArtifacts[fullyQualifiedName];
        const contractName = fullyQualifiedName.split(':')[1];
        const iface = new ethers_1.ethers.Interface(artifact.abi);
        const constructorFragment = iface.fragments.find(ethers_1.ConstructorFragment.isFragment);
        let variables = {};
        if (constructorFragment) {
            const encodedConstructorArgs = (0, core_1.getAbiEncodedConstructorArgs)(initCodeWithArgs, artifact.bytecode);
            const constructorArgsResult = coder.decode(constructorFragment.inputs, encodedConstructorArgs);
            variables = (0, contracts_1.recursivelyConvertResult)(constructorFragment.inputs, constructorArgsResult);
        }
        return {
            referenceName: contractName,
            functionName: 'deploy',
            variables,
            address: contractAddress,
            value,
        };
    }
    else {
        return {
            referenceName: contractAddress,
            functionName: 'deploy',
            variables: [],
            address: contractAddress,
            value,
        };
    }
};
exports.makeContractDecodedAction = makeContractDecodedAction;
const makeFunctionCallDecodedAction = (to, data, value, configArtifacts, fullyQualifiedName) => {
    if (fullyQualifiedName) {
        const { artifact } = configArtifacts[fullyQualifiedName];
        const contractName = fullyQualifiedName.split(':')[1];
        const iface = new ethers_1.ethers.Interface(artifact.abi);
        const decoded = (0, core_1.decodeCall)(iface, data);
        const functionName = decoded ? decoded.functionName : 'call';
        const variables = decoded
            ? decoded.variables
            : [data.length > 1000 ? `Calldata is too large to display.` : data];
        return {
            referenceName: contractName,
            functionName,
            variables,
            address: to,
            value,
        };
    }
    else {
        const variables = [
            data.length > 1000 ? `Calldata is too large to display.` : data,
        ];
        return {
            referenceName: to,
            functionName: 'call',
            variables,
            address: '',
            value,
        };
    }
};
exports.makeFunctionCallDecodedAction = makeFunctionCallDecodedAction;
const abiDecodeUint256 = (encoded) => {
    const coder = ethers_1.AbiCoder.defaultAbiCoder();
    const result = coder.decode(['uint256'], encoded);
    return result.toString();
};
const abiDecodeUint256Array = (encoded) => {
    const coder = ethers_1.AbiCoder.defaultAbiCoder();
    const [result] = coder.decode(['uint256[]'], encoded);
    return result.map((r) => r.toString());
};
const abiDecodeString = (encoded) => {
    const coder = ethers_1.AbiCoder.defaultAbiCoder();
    const result = coder.decode(['string'], encoded);
    return result.toString();
};
//# sourceMappingURL=decode.js.map