import { spawnAsync } from '@sphinx-labs/core/dist/utils';
import { ActionInput, ConfigArtifacts, DeploymentInfo, GetConfigArtifacts, NetworkConfig, ParsedVariable, SphinxConfigWithAddresses } from '@sphinx-labs/core/dist/config/types';
import { SphinxJsonRpcProvider, TransactionEstimatedGas } from '@sphinx-labs/core';
import ora from 'ora';
import { ContractArtifact, LinkReferences, ParsedAccountAccess, AccountAccess } from '@sphinx-labs/contracts';
import { ConstructorFragment, ethers } from 'ethers';
import { FoundryMultiChainDryRun, FoundrySingleChainBroadcast, FoundrySingleChainDryRun, FoundryToml } from '../types';
import { SimulationTransactions } from '../../hardhat/simulate';
import { GetNetworkGasEstimate } from '../../cli/types';
import { SphinxContext } from '../../cli/context';
export declare const streamBuildInfoCacheContracts: (filePath: string) => Promise<{
    fullyQualifiedName: string;
    bytecode: string;
    linkReferences: LinkReferences;
    constructorFragment?: ConstructorFragment | undefined;
}[]>;
export declare const streamBuildInfo: (filePath: string) => Promise<any>;
export declare const messageArtifactNotFound: (fullyQualifiedName: string) => string;
export declare const messageMultipleArtifactsFound: (contractNameOrFullyQualifiedName: string) => string;
export declare const readContractArtifact: (fullyQualifiedName: string, projectRoot: string, artifactFolder: string) => Promise<ContractArtifact>;
export declare const getInitCodeWithArgsArray: (accountAccesses: Array<ParsedAccountAccess>) => Array<string>;
export declare const compile: (silent: boolean, force: boolean, buildInfo: boolean) => void;
export declare const assertNoLinkedLibraries: (scriptPath: string, cachePath: string, artifactFolder: string, projectRoot: string, targetContract?: string) => Promise<void>;
export declare const makeGetConfigArtifacts: (artifactFolder: string, buildInfoFolder: string, projectRoot: string, cachePath: string) => GetConfigArtifacts;
export declare const inferSolcVersion: () => Promise<string>;
export declare const isInitCodeMatch: (actualInitCodeWithArgs: string, artifact: {
    bytecode: string;
    linkReferences: LinkReferences;
    constructorFragment?: ethers.ConstructorFragment;
}) => boolean;
export declare const getSphinxConfigFromScript: (scriptPath: string, sphinxPluginTypesInterface: ethers.Interface, targetContract?: string, spinner?: ora.Ora) => Promise<SphinxConfigWithAddresses>;
type ForgeScriptResponse<T> = {
    logs: Array<string>;
    returns: T;
};
export declare const getForgeScriptArgs: (scriptPath: string, signature: string, args: string[], forkUrl?: string, targetContract?: string, silent?: boolean, json?: boolean, broadcast?: boolean) => string[];
export declare const callForgeScriptFunction: <T>(scriptPath: string, signature: string, args: string[], forkUrl?: string, targetContract?: string, spinner?: ora.Ora) => Promise<ForgeScriptResponse<T>>;
export declare const isFoundryMultiChainDryRun: (dryRun: FoundrySingleChainDryRun | FoundryMultiChainDryRun) => dryRun is FoundryMultiChainDryRun;
export declare const isFoundrySingleChainDryRun: (dryRun: FoundrySingleChainDryRun | FoundryMultiChainDryRun) => dryRun is FoundrySingleChainDryRun;
export declare const readFoundryMultiChainDryRun: (broadcastFolder: string, scriptPath: string, functionNameOrSelector: string, timeThreshold: Date) => FoundryMultiChainDryRun | undefined;
export declare const getFoundrySingleChainDryRunPath: (broadcastFolder: string, scriptPath: string, chainId: string | bigint | number, functionNameOrSelector: string) => string;
export declare const readFoundrySingleChainBroadcast: (broadcastFolder: string, scriptPath: string, chainId: string | number | bigint, functionNameOrSelector: string, timeThreshold: Date) => FoundrySingleChainBroadcast | undefined;
export declare const readFoundrySingleChainDryRun: (broadcastFolder: string, scriptPath: string, chainId: string | bigint | number, functionNameOrSelector: string, timeThreshold: Date) => FoundrySingleChainDryRun | undefined;
export declare const readInterface: (artifactFolder: string, contractName: string) => ethers.Interface;
export declare const findFunctionFragment: (iface: ethers.Interface, fragmentName: string) => ethers.FunctionFragment;
export declare const convertLibraryFormat: (librariesArray: Array<string>) => Array<string>;
export declare const getEstimatedGas: (transactions: SimulationTransactions, provider: SphinxJsonRpcProvider) => Promise<{
    estimatedGas: string;
    transactionsWithGasEstimates: Array<TransactionEstimatedGas>;
}>;
export declare const getNetworkGasEstimate: GetNetworkGasEstimate;
export declare const replaceEnvVariables: (input: ParsedVariable) => any;
export declare const findFullyQualifiedNameForInitCode: (initCodeWithArgs: string, configArtifacts: ConfigArtifacts) => string | undefined;
export declare const findFullyQualifiedNameForAddress: (address: string, accountAccesses: Array<ParsedAccountAccess>, configArtifacts: ConfigArtifacts) => string | undefined;
export declare const writeSystemContracts: (sphinxPluginTypesInterface: ethers.Interface, cachePath: string) => string;
export declare const isCreate2AccountAccess: (root: AccountAccess, nested: Array<AccountAccess>) => boolean;
export declare const parseNestedContractDeployments: (nested: Array<AccountAccess>, configArtifacts: ConfigArtifacts) => {
    parsedContracts: ActionInput['contracts'];
    unlabeled: NetworkConfig['unlabeledContracts'];
};
export declare const assertValidVersions: (scriptPath: string, targetContract?: string) => Promise<void>;
export declare const isDeploymentInfo: (obj: any) => obj is DeploymentInfo;
export declare const parseScriptFunctionCalldata: (sig: Array<string>, spawnAsyncFunction?: typeof spawnAsync) => Promise<string>;
export declare const validateProposalNetworks: (cliNetworks: Array<string>, configTestnets: Array<string>, configMainnets: Array<string>, rpcEndpoints: FoundryToml['rpcEndpoints'], isLiveNetwork: SphinxContext['isLiveNetwork']) => Promise<{
    rpcUrls: Array<string>;
    isTestnet: boolean;
}>;
export {};
