"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUndeployedContractErrorMesage = exports.createHardhatEthersProviderProxy = exports.handleSimulationSuccess = exports.simulateDeploymentSubtask = exports.fetchTransactionResponses = exports.setupPresimulationState = exports.simulate = exports.simulationConstants = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const core_1 = require("@sphinx-labs/core");
const ethers_1 = require("ethers");
const p_limit_1 = __importDefault(require("p-limit"));
const error_messages_1 = require("../foundry/error-messages");
exports.simulationConstants = {
    maxAttempts: 10,
    timeout: 150000,
};
const simulate = async (deploymentConfig, chainId, rpcUrl) => {
    const rootPluginPath = process.env.DEV_FILE_PATH ?? (0, path_1.join)('node_modules', '@sphinx-labs', 'plugins');
    const provider = new core_1.SphinxJsonRpcProvider(rpcUrl);
    const networkConfig = (0, core_1.fetchNetworkConfigFromDeploymentConfig)(BigInt(chainId), deploymentConfig);
    const expectedHardhatConfigPath = (0, path_1.join)(rootPluginPath, 'dist', 'hardhat.config.js');
    if (!(0, fs_1.existsSync)(expectedHardhatConfigPath)) {
        throw new Error('Failed to locate simulation configuration. This is a bug, please report it to the developers');
    }
    const envVars = {
        SPHINX_INTERNAL__FORK_URL: rpcUrl,
        SPHINX_INTERNAL__CHAIN_ID: chainId,
        SPHINX_INTERNAL__BLOCK_GAS_LIMIT: networkConfig.blockGasLimit,
        HARDHAT_CONFIG: expectedHardhatConfigPath,
    };
    const taskParams = {
        deploymentConfig,
        chainId,
    };
    if ((await (0, core_1.isLiveNetwork)(provider)) || (await (0, core_1.isFork)(provider))) {
        envVars['SPHINX_INTERNAL__BLOCK_NUMBER'] = networkConfig.blockNumber;
    }
    else {
        const blocksToFastForward = (0, core_1.getLargestPossibleReorg)(chainId);
        const blocksHex = (0, core_1.stripLeadingZero)(ethers_1.ethers.toBeHex(blocksToFastForward));
        await provider.send('hardhat_mine', [blocksHex]);
    }
    const hardhatRunnerPath = (0, path_1.join)(rootPluginPath, 'dist', 'hardhat', 'hardhatRunner.js');
    const { stdout, stderr, code } = await (0, core_1.spawnAsync)('node', [hardhatRunnerPath], envVars, JSON.stringify(taskParams));
    if (code !== 0) {
        const networkName = (0, core_1.fetchNameForNetwork)(BigInt(chainId));
        let errorMessage = `Simulation failed for ${networkName} at block number ${networkConfig.blockNumber}.`;
        try {
            const error = JSON.parse(stdout);
            if (typeof error.stack === 'string' &&
                error.stack.includes(error.message)) {
                errorMessage += `\n\n${error.stack}`;
            }
            else {
                errorMessage += `\n\n${error.message}\n\n${error.stack}`;
            }
        }
        catch {
            errorMessage += `\n\n${stdout}`;
        }
        throw new Error(errorMessage);
    }
    try {
        const transactions = JSON.parse(stdout).transactions;
        return { transactions };
    }
    catch (e) {
        console.log(stdout);
        console.error(stderr);
        process.exit(1);
    }
};
exports.simulate = simulate;
const setupPresimulationState = async (provider, executionMode) => {
    let signer;
    if (executionMode === core_1.ExecutionMode.LiveNetworkCLI) {
        const privateKey = process.env.PRIVATE_KEY;
        if (!privateKey) {
            throw new Error(`Could not find 'PRIVATE_KEY' environment variable.`);
        }
        signer = new ethers_1.ethers.Wallet(privateKey, provider);
    }
    else if (executionMode === core_1.ExecutionMode.LocalNetworkCLI ||
        executionMode === core_1.ExecutionMode.Platform) {
        signer = new ethers_1.ethers.Wallet((0, core_1.getSphinxWalletPrivateKey)(0), provider);
        await (0, core_1.fundAccountMaxBalance)(signer.address, provider);
    }
    else {
        throw new Error(`Unknown execution mode.`);
    }
    return signer;
};
exports.setupPresimulationState = setupPresimulationState;
const fetchTransactionResponses = async (receipts, provider) => {
    const chainId = (await provider.getNetwork()).chainId;
    const limit = (0, p_limit_1.default)(5);
    const transactions = await Promise.all(receipts.map(async (receipt) => {
        const response = await limit(async () => provider.getTransaction(receipt.hash));
        const sphinxResponse = (0, core_1.convertEthersTransactionResponse)(response, chainId.toString());
        return {
            receipt,
            response: sphinxResponse,
        };
    }));
    return transactions;
};
exports.fetchTransactionResponses = fetchTransactionResponses;
const simulateDeploymentSubtask = async (taskArgs, hre) => {
    const provider = (0, exports.createHardhatEthersProviderProxy)(hre.ethers.provider);
    const { deploymentConfig, chainId } = taskArgs;
    const { merkleTree } = deploymentConfig;
    const networkConfig = (0, core_1.fetchNetworkConfigFromDeploymentConfig)(BigInt(chainId), deploymentConfig);
    const { executionMode } = networkConfig;
    const signer = await (0, exports.setupPresimulationState)(provider, executionMode);
    const sphinxWallets = (0, core_1.getSphinxWalletsSortedByAddress)(BigInt(networkConfig.newConfig.threshold), provider);
    const treeSigners = await Promise.all(sphinxWallets.map(async (wallet) => {
        return {
            signer: await wallet.getAddress(),
            signature: await (0, core_1.signMerkleRoot)(merkleTree.root, wallet),
        };
    }));
    let receipts;
    const deployment = {
        id: 'only required on website',
        multichainDeploymentId: 'only required on website',
        projectId: 'only required on website',
        chainId: networkConfig.chainId,
        status: 'approved',
        moduleAddress: networkConfig.moduleAddress,
        safeAddress: networkConfig.safeAddress,
        deploymentConfig,
        networkName: (0, core_1.fetchNameForNetwork)(BigInt(networkConfig.chainId)),
        treeSigners,
    };
    const simulationContext = {
        throwError: (message) => {
            throw new Error(message);
        },
        handleError: (e) => {
            throw e;
        },
        handleAlreadyExecutedDeployment: async (deploymentContext) => {
            receipts = (await (0, core_1.fetchExecutionTransactionReceipts)([], deploymentContext.deployment.moduleAddress, deploymentContext.deployment.deploymentConfig.merkleTree.root, deploymentContext.provider)).map(core_1.convertEthersTransactionReceipt);
        },
        handleExecutionFailure: (_deploymentContext, _networkConfig, failureReason) => {
            throw new Error(`The following action reverted during the simulation:\n${failureReason.reason}`);
        },
        handleSuccess: async () => (0, exports.handleSimulationSuccess)(networkConfig, provider),
        executeTransaction: core_1.executeTransactionViaSigner,
        deployment,
        provider,
        injectRoles: core_1.injectRoles,
        removeRoles: core_1.removeRoles,
        wallet: signer,
    };
    const result = await core_1.sphinxCoreExecute.attemptDeployment(simulationContext);
    if (!result) {
        throw new Error('Simulation failed for an unexpected reason. This is a bug. Please report it to the developers.');
    }
    const { finalStatus, failureAction } = result;
    receipts = result.receipts;
    if (!receipts) {
        throw new Error('Simulation failed for an unexpected reason. This is a bug. Please report it to the developers.');
    }
    if (finalStatus === core_1.MerkleRootStatus.FAILED) {
        if (failureAction) {
            throw new Error(`The following action reverted during the simulation:\n${failureAction.reason}`);
        }
        else {
            throw new Error(`An action reverted during the simulation.`);
        }
    }
    return {
        transactions: await (0, exports.fetchTransactionResponses)(receipts, provider),
    };
};
exports.simulateDeploymentSubtask = simulateDeploymentSubtask;
const handleSimulationSuccess = async (networkConfig, provider) => {
    const contractAddresses = (0, core_1.getContractAddressesFromNetworkConfig)(networkConfig);
    const limit = (0, p_limit_1.default)(3);
    await Promise.all(contractAddresses.map((address) => limit(async () => {
        if ((await provider.getCode(address)) === '0x') {
            throw new core_1.InvariantError((0, exports.getUndeployedContractErrorMesage)(address));
        }
    })));
    return;
};
exports.handleSimulationSuccess = handleSimulationSuccess;
const createHardhatEthersProviderProxy = (ethersProvider) => {
    const proxy = new Proxy(ethersProvider, {
        get: (target, prop) => {
            return (...args) => {
                if (!core_1.sphinxCoreUtils.isPublicAsyncMethod(ethersProvider, prop)) {
                    return target[prop](...args);
                }
                const invokeWithRetryAndSnapshot = async () => {
                    if (args.length > 0 && args[0] === 'hardhat_reset') {
                        throw new Error(error_messages_1.HardhatResetNotAllowedErrorMessage);
                    }
                    let snapshotId;
                    for (let attempt = 0; attempt < exports.simulationConstants.maxAttempts; attempt++) {
                        snapshotId = await target.send('evm_snapshot', []);
                        try {
                            const result = await core_1.sphinxCoreUtils.callWithTimeout(target[prop](...args), exports.simulationConstants.timeout, (0, error_messages_1.getRpcRequestStalledErrorMessage)(exports.simulationConstants.timeout));
                            if (prop === 'getSigner') {
                                return result.connect(proxy);
                            }
                            else {
                                return result;
                            }
                        }
                        catch (error) {
                            const success = await target.send('evm_revert', [snapshotId]);
                            if (!success) {
                                throw new core_1.InvariantError(`Failed to call 'evm_revert'.`);
                            }
                            if (attempt === exports.simulationConstants.maxAttempts - 1) {
                                throw error;
                            }
                            const sleepTime = 2 * (attempt + 1) * 1000;
                            await core_1.sphinxCoreUtils.sleep(sleepTime);
                        }
                    }
                };
                return Promise.resolve({
                    then: (resolve, reject) => {
                        ;
                        (async () => {
                            try {
                                const result = await invokeWithRetryAndSnapshot();
                                resolve(result);
                            }
                            catch (error) {
                                reject(error);
                            }
                        })();
                    },
                });
            };
        },
    });
    return proxy;
};
exports.createHardhatEthersProviderProxy = createHardhatEthersProviderProxy;
const getUndeployedContractErrorMesage = (address) => `Simulation succeeded, but the following contract wasn't deployed at its expected address:\n` +
    address;
exports.getUndeployedContractErrorMesage = getUndeployedContractErrorMesage;
//# sourceMappingURL=simulate.js.map