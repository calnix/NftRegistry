"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.propose = exports.buildNetworkConfigArray = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const core_1 = require("@sphinx-labs/core");
const ora_1 = __importDefault(require("ora"));
const chalk_1 = require("chalk");
const contracts_1 = require("@sphinx-labs/contracts");
const decode_1 = require("../../foundry/decode");
const options_1 = require("../../foundry/options");
const utils_1 = require("../../foundry/utils");
const buildNetworkConfigArray = async (scriptPath, scriptFunctionCalldata, safeAddress, rpcUrls, sphinxPluginTypesInterface, foundryToml, projectRoot, getConfigArtifacts, targetContract, spinner) => {
    const deploymentInfoPath = (0, path_1.join)(foundryToml.cachePath, 'sphinx-deployment-info.txt');
    const collected = [];
    for (const rpcUrl of rpcUrls) {
        if ((0, fs_1.existsSync)(deploymentInfoPath)) {
            (0, fs_1.unlinkSync)(deploymentInfoPath);
        }
        const provider = new core_1.SphinxJsonRpcProvider(rpcUrl);
        const blockNumber = await provider.getBlockNumber();
        const forgeScriptCollectArgs = [
            'script',
            scriptPath,
            '--rpc-url',
            rpcUrl,
            '--sig',
            'sphinxCollectProposal(bytes,string,uint64)',
            scriptFunctionCalldata,
            deploymentInfoPath,
            '--always-use-create-2-factory',
            core_1.DEFAULT_CALL_DEPTH,
        ];
        if ((0, core_1.isLegacyTransactionsRequiredForNetwork)((await provider.getNetwork()).chainId)) {
            forgeScriptCollectArgs.push('--legacy');
        }
        if (targetContract) {
            forgeScriptCollectArgs.push('--target-contract', targetContract);
        }
        const spawnOutput = await (0, core_1.spawnAsync)('forge', forgeScriptCollectArgs, {
            FOUNDRY_BLOCK_GAS_LIMIT: core_1.MAX_UINT64.toString(),
            ETH_FROM: safeAddress,
            FOUNDRY_BUILD_INFO: 'false',
        });
        if (spawnOutput.code !== 0) {
            spinner?.stop();
            console.log(spawnOutput.stdout);
            console.log(spawnOutput.stderr);
            process.exit(1);
        }
        const serializedDeploymentInfo = (0, fs_1.readFileSync)(deploymentInfoPath, 'utf-8');
        const deploymentInfo = (0, decode_1.decodeDeploymentInfo)(serializedDeploymentInfo, sphinxPluginTypesInterface, blockNumber);
        collected.push({
            deploymentInfo,
            libraries: [],
            rpcUrl,
        });
    }
    spinner?.succeed(`Collected transactions.`);
    spinner?.start(`Building proposal...`);
    const initCodeWithArgsArray = (0, utils_1.getInitCodeWithArgsArray)(collected.flatMap(({ deploymentInfo }) => deploymentInfo.accountAccesses));
    const { configArtifacts, buildInfos } = await getConfigArtifacts(initCodeWithArgsArray);
    //await (0, utils_1.assertNoLinkedLibraries)(scriptPath, foundryToml.cachePath, foundryToml.artifactFolder, projectRoot, targetContract);
    const networkConfigArrayWithRpcUrls = collected.map(({ deploymentInfo, libraries, rpcUrl }) => {
        return {
            rpcUrl,
            networkConfig: (0, decode_1.makeNetworkConfig)(deploymentInfo, true, configArtifacts, libraries),
        };
    });
    const isEmpty = networkConfigArrayWithRpcUrls.every(({ networkConfig }) => networkConfig.actionInputs.length === 0);
    if (isEmpty) {
        return {
            isEmpty: true,
            networkConfigArrayWithRpcUrls: undefined,
            configArtifacts: undefined,
        };
    }
    return {
        networkConfigArrayWithRpcUrls,
        configArtifacts,
        buildInfos,
        isEmpty: false,
    };
};
exports.buildNetworkConfigArray = buildNetworkConfigArray;
const propose = async (args) => {
    const { confirm, networks, isDryRun, silent, sphinxContext, targetContract } = args;
    const sig = args.sig === undefined ? ['run()'] : args.sig;
    const projectRoot = process.cwd();
    const scriptPath = (0, path_1.relative)(projectRoot, args.scriptPath);
    if (!(0, core_1.isFile)(scriptPath)) {
        throw new Error(`File does not exist at: ${scriptPath}\n` +
            `Please make sure this is a valid file path.`);
    }
    const apiKey = process.env.SPHINX_API_KEY;
    if (!apiKey) {
        console.error("You must specify a 'SPHINX_API_KEY' environment variable.");
        process.exit(1);
    }
    (0, utils_1.compile)(silent, false, true);
    const scriptFunctionCalldata = await (0, utils_1.parseScriptFunctionCalldata)(sig);
    const spinner = (0, ora_1.default)({ isSilent: silent });
    spinner.start(`Validating networks...`);
    await (0, utils_1.assertValidVersions)(scriptPath, targetContract);
    const foundryToml = await (0, options_1.getFoundryToml)();
    const sphinxPluginTypesInterface = (0, utils_1.readInterface)(foundryToml.artifactFolder, 'SphinxPluginTypes');
    const { safeAddress, testnets, mainnets } = await (0, utils_1.getSphinxConfigFromScript)(scriptPath, sphinxPluginTypesInterface, targetContract, spinner);
    const { rpcUrls, isTestnet } = await (0, utils_1.validateProposalNetworks)(networks, testnets, mainnets, foundryToml.rpcEndpoints, sphinxContext.isLiveNetwork);
    spinner.succeed(`Validated networks.`);
    spinner.start(`Collecting transactions...`);
    const getConfigArtifacts = sphinxContext.makeGetConfigArtifacts(foundryToml.artifactFolder, foundryToml.buildInfoFolder, projectRoot, foundryToml.cachePath);
    const { networkConfigArrayWithRpcUrls, configArtifacts, isEmpty, buildInfos, } = await sphinxContext.buildNetworkConfigArray(scriptPath, scriptFunctionCalldata, safeAddress, rpcUrls, sphinxPluginTypesInterface, foundryToml, projectRoot, getConfigArtifacts, targetContract, spinner);
    if (isEmpty) {
        spinner.succeed(`Skipping proposal because there is nothing to execute on any chain.`);
        return {};
    }
    if (!networkConfigArrayWithRpcUrls || !configArtifacts || !buildInfos) {
        throw new Error(`NetworkConfig, ConfigArtifacts, or BuildInfos not defined. Should never happen.`);
    }
    const networkConfigArray = networkConfigArrayWithRpcUrls.map(({ networkConfig }) => networkConfig);
    const deploymentData = (0, core_1.makeDeploymentData)(networkConfigArray);
    const merkleTree = (0, contracts_1.makeSphinxMerkleTree)(deploymentData);
    spinner.succeed(`Built proposal.`);
    spinner.start(`Running simulation...`);
    const deploymentConfig = (0, core_1.makeDeploymentConfig)(networkConfigArray, configArtifacts, buildInfos, merkleTree);
    const gasEstimatesPromises = networkConfigArrayWithRpcUrls
        .filter(({ networkConfig }) => networkConfig.actionInputs.length > 0)
        .map(({ networkConfig, rpcUrl }) => sphinxContext.getNetworkGasEstimate(deploymentConfig, networkConfig.chainId, rpcUrl));
    const gasEstimates = await Promise.all(gasEstimatesPromises);
    spinner.succeed(`Simulation succeeded.`);
    const preview = (0, core_1.getPreview)(networkConfigArray);
    if (confirm || isDryRun) {
        if (!silent) {
            const previewString = (0, core_1.getPreviewString)(preview, false);
            console.log(previewString);
        }
    }
    else {
        const previewString = (0, core_1.getPreviewString)(preview, true);
        await sphinxContext.prompt(previewString);
    }
    isDryRun
        ? spinner.start('Finishing dry run...')
        : spinner.start(`Proposing...`);
    const shouldBeEqual = networkConfigArray.map((networkConfig) => {
        return {
            newConfig: networkConfig.newConfig,
            safeAddress: networkConfig.safeAddress,
            moduleAddress: networkConfig.moduleAddress,
            safeInitData: networkConfig.safeInitData,
        };
    });
    if (!(0, core_1.elementsEqual)(shouldBeEqual)) {
        throw new Error(`Detected different Safe or SphinxModule addresses for different chains. This is currently unsupported.` +
            `Please use the same Safe and SphinxModule on all chains.`);
    }
    const { newConfig, moduleAddress, safeInitData } = networkConfigArray[0];
    const projectDeployments = [];
    const chainStatus = [];
    const chainIds = [];
    for (const networkConfig of networkConfigArray) {
        if (networkConfig.actionInputs.length === 0) {
            continue;
        }
        const projectDeployment = getProjectDeploymentForChain(merkleTree, networkConfig);
        if (projectDeployment) {
            projectDeployments.push(projectDeployment);
        }
        chainStatus.push({
            chainId: Number(networkConfig.chainId),
            numLeaves: networkConfig.actionInputs.length + 1,
        });
        chainIds.push(Number(networkConfig.chainId));
    }
    const proposalRequest = {
        apiKey,
        orgId: newConfig.orgId,
        isTestnet,
        chainIds,
        deploymentName: newConfig.projectName,
        owners: newConfig.owners,
        threshold: Number(newConfig.threshold),
        safeAddress,
        moduleAddress,
        safeInitData,
        safeInitSaltNonce: newConfig.saltNonce,
        projectDeployments,
        gasEstimates,
        diff: preview,
        compilerConfigId: undefined,
        deploymentConfigId: undefined,
        tree: {
            root: merkleTree.root,
            chainStatus,
        },
    };
    const deploymentConfigData = JSON.stringify(deploymentConfig, null, 2);
    if (isDryRun) {
        spinner.succeed(`Proposal dry run succeeded.`);
    }
    else {
        const deploymentConfigId = await sphinxContext.storeDeploymentConfig(apiKey, newConfig.orgId, deploymentConfigData);
        proposalRequest.deploymentConfigId = deploymentConfigId;
        proposalRequest.compilerConfigId = deploymentConfigId;
        await sphinxContext.relayProposal(proposalRequest);
        spinner.succeed(`Proposal succeeded! Go to ${chalk_1.blue.underline(core_1.WEBSITE_URL)} to approve the deployment.`);
    }
    return {
        proposalRequest,
        deploymentConfigData,
        configArtifacts,
        networkConfigArray,
        merkleTree,
    };
};
exports.propose = propose;
const getProjectDeploymentForChain = (merkleTree, networkConfig) => {
    const { newConfig, initialState, chainId } = networkConfig;
    const approvalLeaves = merkleTree.leavesWithProofs.filter((l) => l.leaf.leafType === contracts_1.SphinxLeafType.APPROVE &&
        l.leaf.chainId === BigInt(chainId));
    if (approvalLeaves.length === 0) {
        return undefined;
    }
    else if (approvalLeaves.length > 1) {
        throw new Error(`Found multiple approval leaves for chain ${chainId}. Should never happen.`);
    }
    const deploymentId = merkleTree.root;
    return {
        chainId: Number(chainId),
        deploymentId,
        name: newConfig.projectName,
        isExecuting: initialState.isExecuting,
    };
};
//# sourceMappingURL=index.js.map