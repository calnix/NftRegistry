"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const utils_1 = require("@sphinx-labs/core/dist/utils");
const provider_1 = require("@sphinx-labs/core/dist/provider");
const core_1 = require("@sphinx-labs/core");
const chalk_1 = require("chalk");
const ora_1 = __importDefault(require("ora"));
const ethers_1 = require("ethers");
const contracts_1 = require("@sphinx-labs/contracts");
const utils_2 = require("../foundry/utils");
const options_1 = require("../foundry/options");
const decode_1 = require("../foundry/decode");
const simulate_1 = require("../hardhat/simulate");
const deploy = async (args) => {
    const { network, skipPreview, silent, sphinxContext, verify, targetContract, } = args;
    const sig = args.sig === undefined ? ['run()'] : args.sig;
    const projectRoot = process.cwd();
    const scriptPath = (0, path_1.relative)(projectRoot, args.scriptPath);
    if (!(0, utils_1.isFile)(scriptPath)) {
        throw new Error(`File does not exist at: ${scriptPath}\n` +
            `Please make sure this is a valid file path.`);
    }
    (0, utils_2.compile)(silent, false, true);
    const scriptFunctionCalldata = await (0, utils_2.parseScriptFunctionCalldata)(sig);
    const spinner = (0, ora_1.default)({ isSilent: silent });
    spinner.start(`Collecting transactions...`);
    const foundryToml = await (0, options_1.getFoundryToml)();
    const { artifactFolder, buildInfoFolder, cachePath, rpcEndpoints, etherscan, } = foundryToml;
    await (0, utils_2.assertValidVersions)(scriptPath, targetContract);
    const forkUrl = rpcEndpoints[network];
    if (!forkUrl) {
        console.error((0, chalk_1.red)(`No RPC endpoint specified in your foundry.toml for the network: ${network}.`));
        process.exit(1);
    }
    if (verify) {
        if (!etherscan || !etherscan[network]) {
            console.error((0, chalk_1.red)(`No etherscan configuration detected for ${network}. Please configure it in your foundry.toml file:\n` +
                `[etherscan]\n` +
                `${network} = { key = "<your api key>" }`));
            process.exit(1);
        }
    }
    const provider = new provider_1.SphinxJsonRpcProvider(forkUrl);
    const [isLiveNetwork, { chainId }] = await Promise.all([
        sphinxContext.isLiveNetwork(provider),
        provider.getNetwork(),
    ]);
    const sphinxPluginTypesInterface = (0, utils_2.readInterface)(artifactFolder, 'SphinxPluginTypes');
    const getConfigArtifacts = sphinxContext.makeGetConfigArtifacts(artifactFolder, buildInfoFolder, projectRoot, cachePath);
    const deploymentInfoPath = (0, path_1.join)(cachePath, 'sphinx-deployment-info.txt');
    if ((0, fs_1.existsSync)(deploymentInfoPath)) {
        (0, fs_1.unlinkSync)(deploymentInfoPath);
    }
    const systemContractsFilePath = (0, utils_2.writeSystemContracts)(sphinxPluginTypesInterface, foundryToml.cachePath);
    const blockNumber = await provider.getBlockNumber();
    const executionMode = isLiveNetwork
        ? core_1.ExecutionMode.LiveNetworkCLI
        : core_1.ExecutionMode.LocalNetworkCLI;
    const forgeScriptCollectArgs = [
        'script',
        scriptPath,
        '--sig',
        'sphinxCollectDeployment(bytes,uint8,string,string)',
        scriptFunctionCalldata,
        executionMode.toString(),
        deploymentInfoPath,
        systemContractsFilePath,
        '--rpc-url',
        forkUrl,
        '--always-use-create-2-factory',
    ];
    if ((0, core_1.isLegacyTransactionsRequiredForNetwork)((await provider.getNetwork()).chainId)) {
        forgeScriptCollectArgs.push('--legacy');
    }
    if (targetContract) {
        forgeScriptCollectArgs.push('--target-contract', targetContract);
    }
    const { safeAddress } = await (0, utils_2.getSphinxConfigFromScript)(scriptPath, sphinxPluginTypesInterface, targetContract, spinner);
    const spawnOutput = await (0, utils_1.spawnAsync)('forge', forgeScriptCollectArgs, {
        FOUNDRY_BLOCK_GAS_LIMIT: core_1.MAX_UINT64.toString(),
        ETH_FROM: safeAddress,
        FOUNDRY_BUILD_INFO: 'false',
    });
    if (spawnOutput.code !== 0) {
        spinner.stop();
        console.log(spawnOutput.stdout);
        console.log(spawnOutput.stderr);
        process.exit(1);
    }
    const serializedDeploymentInfo = (0, fs_1.readFileSync)(deploymentInfoPath, 'utf-8');
    const deploymentInfo = (0, decode_1.decodeDeploymentInfo)(serializedDeploymentInfo, sphinxPluginTypesInterface, blockNumber);
    spinner.succeed(`Collected transactions.`);
    spinner.start(`Building deployment...`);
    let signer;
    let inject;
    let remove;
    if (executionMode === core_1.ExecutionMode.LiveNetworkCLI) {
        const privateKey = process.env.PRIVATE_KEY;
        if (!privateKey) {
            throw new Error(`Could not find 'PRIVATE_KEY' environment variable.`);
        }
        signer = new ethers_1.ethers.Wallet(privateKey, provider);
        inject = async () => {
            return;
        };
        remove = async () => {
            return;
        };
    }
    else if (executionMode === core_1.ExecutionMode.LocalNetworkCLI) {
        signer = new ethers_1.ethers.Wallet((0, utils_1.getSphinxWalletPrivateKey)(0), provider);
        await (0, utils_1.fundAccountMaxBalance)(signer.address, provider);
        inject = core_1.injectRoles;
        remove = core_1.removeRoles;
    }
    else {
        throw new Error(`Unknown execution mode.`);
    }
    const initCodeWithArgsArray = (0, utils_2.getInitCodeWithArgsArray)(deploymentInfo.accountAccesses);
    const { configArtifacts, buildInfos } = await getConfigArtifacts(initCodeWithArgsArray);
    await (0, utils_2.assertNoLinkedLibraries)(scriptPath, foundryToml.cachePath, foundryToml.artifactFolder, projectRoot, targetContract);
    const isSystemDeployed = await (0, core_1.checkSystemDeployed)(provider);
    const networkConfig = (0, decode_1.makeNetworkConfig)(deploymentInfo, isSystemDeployed, configArtifacts, []);
    if (networkConfig.actionInputs.length === 0) {
        spinner.info(`Nothing to deploy. Exiting early.`);
        return {};
    }
    const deploymentData = (0, core_1.makeDeploymentData)([networkConfig]);
    const merkleTree = (0, contracts_1.makeSphinxMerkleTree)(deploymentData);
    const deploymentConfig = (0, core_1.makeDeploymentConfig)([networkConfig], configArtifacts, buildInfos, merkleTree);
    await (0, simulate_1.simulate)(deploymentConfig, chainId.toString(), forkUrl);
    spinner.succeed(`Built deployment.`);
    let preview;
    if (skipPreview) {
        spinner.info(`Skipping preview.`);
    }
    else {
        preview = (0, core_1.getPreview)([networkConfig]);
        spinner.stop();
        const previewString = (0, core_1.getPreviewString)(preview, true);
        await sphinxContext.prompt(previewString);
    }
    const treeSigner = {
        signer: signer.address,
        signature: await (0, utils_1.signMerkleRoot)(merkleTree.root, signer),
    };
    const deployment = {
        id: 'only required on website',
        multichainDeploymentId: 'only required on website',
        projectId: 'only required on website',
        chainId: networkConfig.chainId,
        status: 'approved',
        moduleAddress: networkConfig.moduleAddress,
        safeAddress: networkConfig.safeAddress,
        deploymentConfig,
        networkName: (0, core_1.fetchNameForNetwork)(BigInt(networkConfig.chainId)),
        treeSigners: [treeSigner],
    };
    const deploymentContext = {
        throwError: (message) => {
            throw new Error(message);
        },
        handleError: (e) => {
            throw e;
        },
        handleAlreadyExecutedDeployment: () => {
            throw new Error('Deployment has already been executed. This is a bug. Please report it to the developers.');
        },
        handleExecutionFailure: (_deploymentContext, _networkConfig, failureReason) => {
            throw new Error(`The following action reverted during the execution:\n${failureReason.reason}`);
        },
        handleSuccess: async () => {
            return;
        },
        executeTransaction: core_1.executeTransactionViaSigner,
        injectRoles: inject,
        removeRoles: remove,
        deployment,
        wallet: signer,
        provider,
        spinner,
    };
    const result = await (0, core_1.attemptDeployment)(deploymentContext);
    if (!result) {
        throw new Error('Simulation failed for an unexpected reason. This is a bug. Please report it to the developers.');
    }
    const { receipts } = result;
    spinner.start(`Building deployment artifacts...`);
    const { projectName } = networkConfig.newConfig;
    const networkArtifacts = (0, utils_1.readDeploymentArtifactsForNetwork)(projectName, chainId, executionMode);
    const deploymentArtifacts = {
        networks: {
            [chainId.toString()]: networkArtifacts,
        },
        compilerInputs: {},
    };
    await (0, core_1.makeDeploymentArtifacts)({
        [chainId.toString()]: {
            provider,
            deploymentConfig,
            receipts,
        },
    }, merkleTree.root, configArtifacts, deploymentArtifacts);
    spinner.succeed(`Built deployment artifacts.`);
    spinner.start(`Writing deployment artifacts...`);
    (0, core_1.writeDeploymentArtifacts)(projectName, networkConfig.executionMode, deploymentArtifacts);
    spinner.succeed(`Wrote deployment artifacts.`);
    if (!silent) {
        (0, utils_1.displayDeploymentTable)(networkConfig);
    }
    if (networkConfig.executionMode === core_1.ExecutionMode.LiveNetworkCLI && verify) {
        spinner.info(`Verifying contracts on Etherscan.`);
        const etherscanApiKey = etherscan[network].key;
        await (0, core_1.verifyDeploymentWithRetries)(deploymentConfig, provider, etherscanApiKey);
    }
    return {
        deploymentConfig,
        merkleTree,
        preview,
        receipts,
        configArtifacts,
        deploymentArtifacts,
    };
};
exports.deploy = deploy;
//# sourceMappingURL=deploy.js.map