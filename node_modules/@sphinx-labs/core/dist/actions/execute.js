"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sphinxCoreExecute = exports.attemptDeployment = exports.fetchExecutionTransactionReceipts = exports.sortSigners = exports.handleStatus = exports.estimateGasViaSigner = exports.estimateGasViaManagedService = exports.executeActionsViaSigner = exports.executeActionsViaManagedService = exports.approveDeploymentViaManagedService = exports.removeRoles = exports.injectRoles = exports.executeTransactionViaSigner = exports.approveDeploymentViaSigner = exports.isExecutable = exports.executeBatchActions = void 0;
const contracts_1 = require("@sphinx-labs/contracts");
const ethers_1 = require("ethers");
const types_1 = require("./types");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const networks_1 = require("../networks");
const languages_1 = require("../languages");
const artifacts_1 = require("../artifacts");
const findMaxBatchSize = (leaves, maxGasLimit, moduleAddress, estimateGas, chainId) => {
    if (leaves.length === 0) {
        throw new Error(`Must enter at least one Merkle leaf.`);
    }
    for (let i = 1; i <= leaves.length; i++) {
        if (!(0, exports.isExecutable)(leaves.slice(0, i), maxGasLimit, moduleAddress, estimateGas, chainId)) {
            if (i === 1) {
                throw new Error(`Could not find a valid batch size.`);
            }
            else {
                return i - 1;
            }
        }
    }
    return leaves.length;
};
const executeBatchActions = async (leavesOnNetwork, sphinxModuleReadOnly, blockGasLimit, humanReadableActions, executionMode, executeActions, estimateGas, deploymentContext) => {
    const { deployment, logger } = deploymentContext;
    const { chainId } = deployment;
    const executionReceipts = [];
    const batches = [];
    const maxGasLimit = (0, utils_1.getMaxGasLimit)(blockGasLimit, BigInt(chainId));
    const activeRoot = await sphinxModuleReadOnly.activeMerkleRoot();
    let state = await sphinxModuleReadOnly.merkleRootStates(activeRoot);
    if (state.status === types_1.MerkleRootStatus.FAILED) {
        return {
            status: state.status,
            executionReceipts,
            batches,
            failureAction: humanReadableActions[chainId.toString()][Number(state.leavesExecuted) - 2],
        };
    }
    const filtered = leavesOnNetwork.filter((leaf) => {
        return leaf.leaf.index >= state.leavesExecuted;
    });
    if (filtered.length === 0) {
        logger?.info('[Sphinx]: no actions left to execute');
        return { status: state.status, executionReceipts, batches };
    }
    const moduleAddress = await sphinxModuleReadOnly.getAddress();
    let executed = 0;
    while (executed < filtered.length) {
        const batchSize = findMaxBatchSize(filtered.slice(executed), maxGasLimit, moduleAddress, estimateGas, BigInt(chainId));
        const batch = filtered.slice(executed, executed + batchSize);
        logger?.info(`[Sphinx]: executing actions ${executed} to ${executed + batchSize} of ${filtered.length}...`);
        const receipt = await executeActions(batch, executionMode, blockGasLimit, deploymentContext);
        if (!receipt) {
            throw new Error(`Could not find transaction receipt. Should never happen.`);
        }
        executionReceipts.push(receipt);
        batches.push(batch);
        state = await sphinxModuleReadOnly.merkleRootStates(activeRoot);
        if (state.status === types_1.MerkleRootStatus.FAILED) {
            return {
                status: state.status,
                batches,
                executionReceipts,
                failureAction: humanReadableActions[chainId.toString()][Number(state.leavesExecuted) - 2],
            };
        }
        executed += batchSize;
    }
    return { status: state.status, executionReceipts, batches };
};
exports.executeBatchActions = executeBatchActions;
const isExecutable = (selected, maxGasLimit, moduleAddress, estimateGas, chainid) => {
    return maxGasLimit > estimateGas(moduleAddress, selected, chainid);
};
exports.isExecutable = isExecutable;
const approveDeploymentViaSigner = async (merkleRoot, approvalLeafWithProof, executionMode, ownerSignatures, deploymentContext) => {
    const { moduleAddress } = deploymentContext.deployment;
    const sphinxModuleReadOnly = new ethers_1.ethers.Contract(moduleAddress, contracts_1.SphinxModuleABI);
    const packedOwnerSignatures = ethers_1.ethers.solidityPacked(new Array(ownerSignatures.length).fill('bytes'), ownerSignatures);
    const approvalData = sphinxModuleReadOnly.interface.encodeFunctionData('approve', [merkleRoot, approvalLeafWithProof, packedOwnerSignatures]);
    return deploymentContext.executeTransaction(deploymentContext, {
        to: moduleAddress,
        data: approvalData,
        chainId: deploymentContext.deployment.chainId,
    }, executionMode);
};
exports.approveDeploymentViaSigner = approveDeploymentViaSigner;
const executeTransactionViaSigner = async (deploymentContext, transaction, executionMode) => {
    const { wallet } = deploymentContext;
    if (!wallet) {
        throw new Error('No signer passed to executeTransaction. This is a bug, please report it to the developers.');
    }
    const txReceipt = await (await wallet.sendTransaction(await (0, utils_1.getGasPriceOverrides)(deploymentContext.provider, wallet, executionMode, transaction))).wait();
    if (txReceipt === null) {
        throw new Error('No transaction receipt returned by ethers. This is a bug, please report it to the developers.');
    }
    return txReceipt;
};
exports.executeTransactionViaSigner = executeTransactionViaSigner;
const injectRoles = async (deploymentContext, executionMode) => {
    const { wallet } = deploymentContext;
    if (!wallet) {
        throw new Error('No wallet provided when injecting roles. This is a bug, please report it to the developers.');
    }
    await (0, utils_1.setManagedServiceRelayer)(wallet.address, deploymentContext.provider);
    await (0, utils_1.addSphinxWalletsToGnosisSafeOwners)(deploymentContext.deployment.safeAddress, deploymentContext.deployment.moduleAddress, executionMode, deploymentContext.provider);
};
exports.injectRoles = injectRoles;
const removeRoles = async (deploymentContext, networkConfig, executionMode) => {
    const sphinxWallets = (0, utils_1.getSphinxWalletsSortedByAddress)(BigInt(networkConfig.newConfig.threshold), deploymentContext.provider);
    await (0, utils_1.removeSphinxWalletsFromGnosisSafeOwners)(sphinxWallets, networkConfig.safeAddress, networkConfig.moduleAddress, executionMode, deploymentContext.provider);
};
exports.removeRoles = removeRoles;
const approveDeploymentViaManagedService = async (merkleRoot, approvalLeafWithProof, executionMode, ownerSignatures, deploymentContext) => {
    const { moduleAddress } = deploymentContext.deployment;
    const managedServiceReadOnly = new ethers_1.ethers.Contract((0, contracts_1.getManagedServiceAddress)(), contracts_1.ManagedServiceABI);
    const packedOwnerSignatures = ethers_1.ethers.solidityPacked(new Array(ownerSignatures.length).fill('bytes'), ownerSignatures);
    const sphinxModuleReadOnly = new ethers_1.ethers.Contract(moduleAddress, contracts_1.SphinxModuleABI);
    const approvalData = sphinxModuleReadOnly.interface.encodeFunctionData('approve', [merkleRoot, approvalLeafWithProof, packedOwnerSignatures]);
    const execData = managedServiceReadOnly.interface.encodeFunctionData('exec', [
        moduleAddress,
        approvalData,
    ]);
    return deploymentContext.executeTransaction(deploymentContext, {
        to: (0, contracts_1.getManagedServiceAddress)(),
        data: execData,
        chainId: deploymentContext.deployment.chainId,
    }, executionMode);
};
exports.approveDeploymentViaManagedService = approveDeploymentViaManagedService;
const executeActionsViaManagedService = async (batch, executionMode, blockGasLimit, deploymentContext) => {
    const { provider } = deploymentContext;
    const { moduleAddress, chainId } = deploymentContext.deployment;
    const managedService = new ethers_1.ethers.Contract((0, contracts_1.getManagedServiceAddress)(), contracts_1.ManagedServiceABI);
    const sphinxModuleReadOnly = new ethers_1.ethers.Contract(moduleAddress, contracts_1.SphinxModuleABI, provider);
    const executionData = sphinxModuleReadOnly.interface.encodeFunctionData('execute', [batch]);
    const managedServiceExecData = managedService.interface.encodeFunctionData('exec', [moduleAddress, executionData]);
    let minimumActionsGasLimit;
    if ((0, networks_1.shouldBufferExecuteActionsGasLimit)(BigInt(chainId))) {
        minimumActionsGasLimit = (0, exports.estimateGasViaManagedService)(moduleAddress, batch, BigInt(deploymentContext.deployment.chainId));
    }
    return deploymentContext.executeTransaction(deploymentContext, {
        to: (0, contracts_1.getManagedServiceAddress)(),
        data: managedServiceExecData,
        chainId: deploymentContext.deployment.chainId,
    }, executionMode, minimumActionsGasLimit);
};
exports.executeActionsViaManagedService = executeActionsViaManagedService;
const executeActionsViaSigner = async (batch, executionMode, blockGasLimit, deploymentContext) => {
    const { provider, wallet } = deploymentContext;
    const { moduleAddress, chainId } = deploymentContext.deployment;
    const sphinxModuleReadOnly = new ethers_1.ethers.Contract(moduleAddress, contracts_1.SphinxModuleABI, provider);
    const executionData = sphinxModuleReadOnly.interface.encodeFunctionData('execute', [batch]);
    if (!wallet) {
        throw new Error('No signer passed to executeActionsViaSigner. This is a bug, please report it to the developers.');
    }
    const minimumActionGas = (0, exports.estimateGasViaSigner)(moduleAddress, batch, BigInt(deploymentContext.deployment.chainId));
    const overrides = {};
    if ((0, networks_1.shouldBufferExecuteActionsGasLimit)(BigInt(chainId))) {
        const gasEstimate = await wallet.estimateGas({
            to: moduleAddress,
            data: executionData,
        });
        let limit = BigInt(gasEstimate) + BigInt(minimumActionGas);
        const maxGasLimit = (0, utils_1.getMaxGasLimit)(blockGasLimit, BigInt(chainId));
        if (limit > maxGasLimit) {
            limit = maxGasLimit;
        }
        overrides.gasLimit = limit;
    }
    return deploymentContext.executeTransaction(deploymentContext, {
        to: moduleAddress,
        data: executionData,
        gasLimit: overrides.gasLimit?.toString(),
        chainId: deploymentContext.deployment.chainId,
    }, executionMode);
};
exports.executeActionsViaSigner = executeActionsViaSigner;
const getGasPerCalldata = (byte, chainId) => {
    if (byte === 0) {
        return 4;
    }
    else if ((0, networks_1.implementsEIP2028)(chainId)) {
        return 16;
    }
    else {
        return 68;
    }
};
const estimateGasViaManagedService = (moduleAddress, batch, chainId) => {
    const managedServiceIface = new ethers_1.ethers.Interface(contracts_1.ManagedServiceABI);
    const sphinxModuleIface = new ethers_1.ethers.Interface(contracts_1.SphinxModuleABI);
    const moduleCallData = sphinxModuleIface.encodeFunctionData('execute', [
        batch,
    ]);
    const callDataHex = managedServiceIface.encodeFunctionData('exec', [
        moduleAddress,
        moduleCallData,
    ]);
    const callDataGas = ethers_1.ethers
        .getBytes(callDataHex)
        .map((e) => getGasPerCalldata(e, chainId))
        .reduce((a, b) => a + b, 0);
    const managedServiceGas = 0.00000191 * moduleCallData.length * moduleCallData.length +
        0.3789 * moduleCallData.length +
        10205.7165;
    const estimate = 21000 + callDataGas + estimateModuleExecutionGas(batch) + managedServiceGas;
    return Math.round(estimate * 1.05 + 50000);
};
exports.estimateGasViaManagedService = estimateGasViaManagedService;
const estimateGasViaSigner = (moduleAddress, batch, chainId) => {
    const sphinxModuleIface = new ethers_1.ethers.Interface(contracts_1.SphinxModuleABI);
    const callDataHex = sphinxModuleIface.encodeFunctionData('execute', [batch]);
    const callDataGas = ethers_1.ethers
        .getBytes(callDataHex)
        .map((e) => getGasPerCalldata(e, chainId))
        .reduce((a, b) => a + b, 0);
    const estimate = 21000 + callDataGas + estimateModuleExecutionGas(batch);
    return Math.round(estimate * 1.05 + 50000);
};
exports.estimateGasViaSigner = estimateGasViaSigner;
const estimateModuleExecutionGas = (batch) => {
    const decodedBatch = batch.map((e) => e.leaf).map(contracts_1.decodeExecuteLeafData);
    const loopGas = decodedBatch
        .map((e) => e.gas)
        .map(Number)
        .reduce((a, b) => a + b + 24000, 0);
    return 30000 + loopGas;
};
const handleStatus = (status, batches, receipts, failureAction, spinner) => {
    if (status === types_1.MerkleRootStatus.FAILED) {
        spinner?.fail(`Deployment failed.`);
        return { receipts, batches, finalStatus: status, failureAction };
    }
    else if (status === types_1.MerkleRootStatus.CANCELED) {
        spinner?.fail(`Deployment cancelled by user.`);
        return { receipts, batches, finalStatus: status };
    }
    else if (status === types_1.MerkleRootStatus.COMPLETED) {
        spinner?.succeed(`Deployment succeeded.`);
        return { receipts, batches, finalStatus: status };
    }
    else {
        throw new Error(`Unknown status: ${status}`);
    }
};
exports.handleStatus = handleStatus;
const executeDeployment = async (networkConfig, merkleTree, ownerSignatures, deploymentContext) => {
    const { chainId, executionMode, actionInputs } = networkConfig;
    const { spinner, provider } = deploymentContext;
    const humanReadableActions = {
        [chainId]: (0, utils_1.getReadableActions)(actionInputs, chainId),
    };
    let estimateGas;
    let approveDeployment;
    let executeActions;
    if (executionMode === constants_1.ExecutionMode.LocalNetworkCLI ||
        executionMode === constants_1.ExecutionMode.Platform) {
        estimateGas = exports.estimateGasViaManagedService;
        approveDeployment = exports.approveDeploymentViaManagedService;
        executeActions = exports.executeActionsViaManagedService;
    }
    else if (executionMode === constants_1.ExecutionMode.LiveNetworkCLI) {
        estimateGas = exports.estimateGasViaSigner;
        approveDeployment = exports.approveDeploymentViaSigner;
        executeActions = exports.executeActionsViaSigner;
    }
    else {
        throw new Error(`Unknown execution mode.`);
    }
    if (!networkConfig.isSystemDeployed) {
        await (0, languages_1.ensureSphinxAndGnosisSafeDeployed)(provider, deploymentContext.wallet, executionMode, false, [], executionMode === constants_1.ExecutionMode.LiveNetworkCLI ? spinner : undefined);
    }
    if (networkConfig.safeFundingRequest) {
        const safeBalance = await provider.getBalance(networkConfig.safeAddress);
        const { startingBalance, fundsRequested } = networkConfig.safeFundingRequest;
        const requiredBalance = BigInt(startingBalance) + BigInt(fundsRequested);
        if (safeBalance < requiredBalance) {
            await deploymentContext.executeTransaction(deploymentContext, {
                to: networkConfig.safeAddress,
                chainId: networkConfig.chainId,
                value: fundsRequested.toString(),
                data: '0x',
            }, executionMode);
        }
    }
    const sphinxModuleReadOnly = new ethers_1.ethers.Contract(networkConfig.moduleAddress, contracts_1.SphinxModuleABI, deploymentContext.provider);
    const ethersReceipts = [];
    if (!networkConfig.initialState.isSafeDeployed) {
        if ((await provider.getCode(networkConfig.safeAddress)) === '0x') {
            spinner?.start(`Deploying Gnosis Safe and Sphinx Module...`);
            const gnosisSafeProxyFactory = new ethers_1.ethers.Contract((0, contracts_1.getGnosisSafeProxyFactoryAddress)(), contracts_1.GnosisSafeProxyFactoryArtifact.abi);
            const gnosisSafeDeploymentData = gnosisSafeProxyFactory.interface.encodeFunctionData('createProxyWithNonce', [
                (0, contracts_1.getGnosisSafeSingletonAddress)(),
                networkConfig.safeInitData,
                networkConfig.newConfig.saltNonce,
            ]);
            const gnosisSafeDeploymentReceipt = await deploymentContext.executeTransaction(deploymentContext, {
                to: (0, contracts_1.getGnosisSafeProxyFactoryAddress)(),
                data: gnosisSafeDeploymentData,
                chainId: deploymentContext.deployment.chainId,
            }, executionMode);
            ethersReceipts.push(gnosisSafeDeploymentReceipt);
            spinner?.succeed(`Deployed Gnosis Safe and Sphinx Module.`);
        }
    }
    await deploymentContext.injectRoles(deploymentContext, executionMode);
    const approvalLeafWithProof = (0, utils_1.findLeafWithProof)(merkleTree, contracts_1.SphinxLeafType.APPROVE, BigInt(networkConfig.chainId));
    spinner?.start(`Checking deployment status...`);
    const merkleRootState = await sphinxModuleReadOnly.merkleRootStates(merkleTree.root);
    if (merkleRootState.status === types_1.MerkleRootStatus.EMPTY) {
        spinner?.succeed(`Deployment is new.`);
        spinner?.start(`Approving deployment...`);
        const approvalReceipt = await approveDeployment(merkleTree.root, approvalLeafWithProof, executionMode, ownerSignatures, deploymentContext);
        ethersReceipts.push(approvalReceipt);
        await deploymentContext.removeRoles(deploymentContext, networkConfig, executionMode);
        spinner?.succeed(`Approved deployment.`);
    }
    else if (merkleRootState.status !== types_1.MerkleRootStatus.APPROVED) {
        return (0, exports.handleStatus)(merkleRootState.status, [], ethersReceipts, humanReadableActions[chainId.toString()][Number(merkleRootState.leavesExecuted) - 2], spinner);
    }
    else {
        spinner?.succeed(`Deployment is already approved.`);
    }
    spinner?.start(`Executing deployment...`);
    const networkLeaves = merkleTree.leavesWithProofs.filter((leaf) => leaf.leaf.chainId === BigInt(networkConfig.chainId));
    const { status, failureAction, executionReceipts, batches } = await (0, exports.executeBatchActions)(networkLeaves, sphinxModuleReadOnly, BigInt(networkConfig.blockGasLimit), humanReadableActions, executionMode, executeActions, estimateGas, deploymentContext);
    spinner?.succeed(`Executed deployment.`);
    spinner?.start(`Checking final deployment status...`);
    ethersReceipts.push(...executionReceipts);
    return (0, exports.handleStatus)(status, batches, ethersReceipts, failureAction, spinner);
};
const sortSigners = (arr) => {
    arr.sort((a, b) => {
        const aBigInt = BigInt(a.signer);
        const bBigInt = BigInt(b.signer);
        if (aBigInt < bBigInt) {
            return -1;
        }
        else if (aBigInt > bBigInt) {
            return 1;
        }
        else {
            return 0;
        }
    });
};
exports.sortSigners = sortSigners;
const fetchExecutionTransactionReceipts = async (receipts, moduleAddress, merkleRoot, provider) => {
    const module = new ethers_1.ethers.Contract(moduleAddress, contracts_1.SphinxModuleABI, provider);
    const SphinxMerkleRootApprovedFilter = module.filters.SphinxMerkleRootApproved(merkleRoot);
    const SphinxMerkleRootCanceledFilter = module.filters.SphinxMerkleRootCanceled(merkleRoot);
    const SphinxMerkleRootFailedFilter = module.filters.SphinxMerkleRootFailed(merkleRoot);
    const SphinxActionSucceededFilter = module.filters.SphinxActionSucceeded(merkleRoot);
    const SphinxActionFailedFilter = module.filters.SphinxActionFailed(merkleRoot);
    const filters = [
        SphinxMerkleRootApprovedFilter,
        SphinxMerkleRootCanceledFilter,
        SphinxMerkleRootFailedFilter,
        SphinxActionSucceededFilter,
        SphinxActionFailedFilter,
    ];
    const txHashes = receipts.map((r) => r.hash);
    const latestBlock = await provider.getBlockNumber();
    for (const filter of filters) {
        const startingBlock = latestBlock - 1999 > 0 ? latestBlock - 1999 : 0;
        const events = await module.queryFilter(filter, startingBlock, latestBlock);
        for (const event of events) {
            const receipt = await provider.getTransactionReceipt(event.transactionHash);
            if (receipt && !txHashes.includes(receipt.hash)) {
                txHashes.push(receipt.hash);
                receipts.push(receipt);
            }
        }
    }
    return receipts;
};
exports.fetchExecutionTransactionReceipts = fetchExecutionTransactionReceipts;
const attemptDeployment = async (deploymentContext) => {
    const { deployment } = deploymentContext;
    const networkName = deployment.networkName;
    const deploymentId = deployment.id;
    const deploymentConfig = deployment.deploymentConfig;
    deploymentConfig.merkleTree.leavesWithProofs = (0, utils_1.toSphinxLeafWithProofArray)(deploymentConfig.merkleTree.leavesWithProofs);
    const { merkleTree } = deploymentConfig;
    const { logger } = deploymentContext;
    const deploymentTransactionReceipts = [];
    logger?.info(`[Executor ${networkName}]: retrieving the deployment...`);
    deploymentContext.spinner?.start('Preparing for execution...');
    const targetNetworkNetworkConfig = deploymentConfig.networkConfigs.find((config) => config.chainId === deployment.chainId.toString());
    if (!targetNetworkNetworkConfig) {
        await deploymentContext.throwError(`[Executor ${networkName}]: Error could not find target network config. This should never happen please report it to the developers.`, deploymentId, networkName);
        return;
    }
    const moduleAddress = deployment.moduleAddress;
    const sphinxModuleReadOnly = new ethers_1.ethers.Contract(moduleAddress, contracts_1.SphinxModuleABI, deploymentContext.provider);
    if ((await deploymentContext.provider.getCode(moduleAddress)) !== '0x') {
        const deploymentState = await sphinxModuleReadOnly.merkleRootStates(merkleTree.root);
        if (deploymentState.status === types_1.MerkleRootStatus.COMPLETED) {
            await deploymentContext.handleAlreadyExecutedDeployment(deploymentContext, targetNetworkNetworkConfig);
            return;
        }
    }
    deploymentContext.spinner?.start('Execution ready');
    if (deployment.status === 'approved') {
        let receipts = [];
        let batches = [];
        let finalStatus;
        let failureAction;
        try {
            const signers = deployment.treeSigners;
            (0, exports.sortSigners)(signers);
            const signatures = signers
                .map((signer) => signer.signature)
                .filter((signature) => signature !== null);
            ({ receipts, batches, finalStatus, failureAction } =
                await executeDeployment(targetNetworkNetworkConfig, merkleTree, signatures, deploymentContext));
            deploymentTransactionReceipts.push(...receipts);
            if (finalStatus !== types_1.MerkleRootStatus.COMPLETED) {
                await deploymentContext.handleExecutionFailure(deploymentContext, targetNetworkNetworkConfig, failureAction);
                return {
                    receipts: deploymentTransactionReceipts.map(artifacts_1.convertEthersTransactionReceipt),
                    batches,
                    finalStatus,
                    failureAction,
                };
            }
        }
        catch (e) {
            await deploymentContext.handleError(e, deployment);
            return;
        }
        await deploymentContext.handleSuccess(deploymentContext, targetNetworkNetworkConfig);
        logger?.info(`[Executor ${networkName}]: execution successful`, {
            deploymentId,
        });
        return {
            receipts: deploymentTransactionReceipts.map(artifacts_1.convertEthersTransactionReceipt),
            batches,
            finalStatus,
            failureAction,
        };
    }
};
exports.attemptDeployment = attemptDeployment;
exports.sphinxCoreExecute = {
    attemptDeployment: exports.attemptDeployment,
};
//# sourceMappingURL=execute.js.map