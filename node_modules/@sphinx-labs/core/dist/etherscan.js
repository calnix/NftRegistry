"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.builtinChains = exports.verifySphinxSystem = exports.attemptVerification = exports.verifyDeploymentWithRetries = exports.verifySphinxConfig = void 0;
const dotenv = __importStar(require("dotenv"));
const ethers_1 = require("ethers");
const contracts_1 = require("@sphinx-labs/contracts");
const etherscan_1 = require("@nomicfoundation/hardhat-verify/etherscan");
const compiler_1 = require("./languages/solidity/compiler");
const utils_1 = require("./utils");
const networks_1 = require("./networks");
dotenv.config();
const verifySphinxConfig = async (deploymentConfig, provider, apiKey, explorer) => {
    const networkConfig = (0, utils_1.fetchNetworkConfigFromDeploymentConfig)((await provider.getNetwork()).chainId, deploymentConfig);
    for (const actionInput of networkConfig.actionInputs) {
        for (const { address, fullyQualifiedName, initCodeWithArgs, } of actionInput.contracts) {
            const { artifact, buildInfoId } = deploymentConfig.configArtifacts[fullyQualifiedName];
            const buildInfo = deploymentConfig.buildInfos[buildInfoId];
            const minimumCompilerInput = (0, compiler_1.getMinimumCompilerInput)(buildInfo.input, artifact.metadata);
            const encodedConstructorArgs = ethers_1.ethers.dataSlice(initCodeWithArgs, ethers_1.ethers.dataLength(artifact.bytecode));
            const result = await (0, exports.attemptVerification)(address, encodedConstructorArgs, fullyQualifiedName, buildInfo.solcLongVersion, minimumCompilerInput, provider, networkConfig.chainId, apiKey, explorer);
            if (!result.success) {
                throw new Error(`Contract verification failed.\n${result.message}`);
            }
        }
    }
};
exports.verifySphinxConfig = verifySphinxConfig;
const verifyDeploymentWithRetries = async (deploymentConfig, provider, apiKey) => {
    const maxAttempts = 10;
    const networkConfig = (0, utils_1.fetchNetworkConfigFromDeploymentConfig)((await provider.getNetwork()).chainId, deploymentConfig);
    for (const actionInput of networkConfig.actionInputs) {
        for (const { address, fullyQualifiedName, initCodeWithArgs, } of actionInput.contracts) {
            let success = false;
            const contractName = fullyQualifiedName.split(':')[1];
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                const { artifact, buildInfoId } = deploymentConfig.configArtifacts[fullyQualifiedName];
                const buildInfo = deploymentConfig.buildInfos[buildInfoId];
                const minimumCompilerInput = (0, compiler_1.getMinimumCompilerInput)(buildInfo.input, artifact.metadata);
                const encodedConstructorArgs = ethers_1.ethers.dataSlice(initCodeWithArgs, ethers_1.ethers.dataLength(artifact.bytecode));
                const result = await (0, exports.attemptVerification)(address, encodedConstructorArgs, fullyQualifiedName, buildInfo.solcLongVersion, minimumCompilerInput, provider, networkConfig.chainId, apiKey);
                if (result.success) {
                    success = true;
                    break;
                }
                else {
                    console.log(`Verification failed for ${contractName} at ${address} (attempt ${attempt}/${maxAttempts}).\n` +
                        `Retrying in 5 seconds.\n` +
                        `Error message:\n` +
                        result.message +
                        `\n`);
                    await (0, utils_1.sleep)(5000);
                }
            }
            if (!success) {
                console.log(`Failed to verify contract ${contractName} at ${address} after ${maxAttempts} attempts.`);
            }
        }
    }
};
exports.verifyDeploymentWithRetries = verifyDeploymentWithRetries;
const attemptVerification = async (address, encodedConstructorArgs, fullyQualifiedName, solcLongVersion, minimumCompilerInput, provider, chainId, etherscanApiKey, explorer) => {
    const urls = (0, networks_1.fetchEtherscanConfigForNetwork)(BigInt(chainId), explorer);
    if (!urls) {
        throw new Error(`Could not find Etherscan or Blockscout configuration for network with chainId ${chainId}. This is a bug, please report it to the developers.`);
    }
    const contractName = fullyQualifiedName.split(':')[1];
    const deployedBytecode = (0, contracts_1.remove0x)(await provider.getCode(address));
    if (deployedBytecode.length === 0) {
        console.log(`Skipped verifying ${contractName} at ${address} because it is not deployed.`);
        return { success: true };
    }
    const etherscan = new etherscan_1.Etherscan(etherscanApiKey, urls.apiURL, urls.browserURL);
    const contractURL = etherscan.getContractUrl(address);
    let guid;
    try {
        const response = await etherscan.verify(address, JSON.stringify(minimumCompilerInput), fullyQualifiedName, `v${solcLongVersion}`, (0, contracts_1.remove0x)(encodedConstructorArgs));
        guid = response.message;
    }
    catch (err) {
        if (err.message.toLowerCase().includes('already verified')) {
            console.log(`The contract ${address} has already been verified on Etherscan:\n${contractURL}`);
            return { success: true };
        }
        else {
            return { success: false, message: err.message };
        }
    }
    const networkName = (0, networks_1.fetchNameForNetwork)(BigInt(chainId));
    console.log(`Successfully submitted source code for contract ${contractName}\n` +
        `at ${address} on ${networkName} for verification on Etherscan.\n` +
        `Waiting for verification result...`);
    await (0, utils_1.sleep)(700);
    let verificationStatus;
    try {
        verificationStatus = await etherscan.getVerificationStatus(guid);
    }
    catch (err) {
        return { success: false, message: err.message };
    }
    if (!(verificationStatus.isFailure() || verificationStatus.isSuccess())) {
        throw new Error(`The API responded with an unexpected message. Please report this issue to the.\n` +
            `Sphinx team. Contract verification may have succeeded and should be checked manually.\n` +
            `Message: ${verificationStatus.message}`);
    }
    if (verificationStatus.isSuccess()) {
        console.log(`Successfully verified contract ${contractName} on Etherscan:\n${contractURL}`);
        return { success: true };
    }
    else {
        return { success: false, message: verificationStatus.message };
    }
};
exports.attemptVerification = attemptVerification;
const verifySphinxSystem = async (provider, logger) => {
    const etherscanApiKey = process.env.ETHERSCAN_API_KEY;
    if (!etherscanApiKey) {
        logger.error(`[Sphinx]: skipped verifying sphinx contracts. reason: no api key found`);
        return;
    }
    const { name: networkName, chainId } = await provider.getNetwork();
    if (!(0, networks_1.isVerificationSupportedForNetwork)(chainId) ||
        !(await (0, utils_1.isLiveNetwork)(provider))) {
        logger.info(`[Sphinx]: skipped verifying sphinx contracts. reason: etherscan not supported for: ${networkName}`);
        return;
    }
    logger.info('[Sphinx]: attempting to verify the sphinx contracts on etherscan...');
    const contracts = (0, contracts_1.getSphinxConstants)().concat(contracts_1.additionalSystemContractsToVerify);
    try {
        for (const { artifact, expectedAddress, constructorArgs, type, } of contracts) {
            const { sourceName, contractName, abi } = artifact;
            let buildInfo;
            if (type === contracts_1.SystemContractType.SPHINX) {
                buildInfo = contracts_1.sphinxBuildInfo;
                buildInfo.solcLongVersion = (0, utils_1.formatSolcLongVersion)(buildInfo.solcLongVersion);
            }
            else if (type === contracts_1.SystemContractType.OPTIMISM) {
                buildInfo = contracts_1.optimismPeripheryBuildInfo;
            }
            else if (type === contracts_1.SystemContractType.GNOSIS_SAFE) {
                buildInfo = contracts_1.gnosisSafeBuildInfo;
            }
            else {
                throw new Error(`Unknown system contract type. Should never happen.`);
            }
            const contractOutput = buildInfo.output.contracts[sourceName][contractName];
            const metadata = typeof contractOutput.metadata === 'string'
                ? JSON.parse(contractOutput.metadata)
                : contractOutput.metadata;
            const minimumCompilerInput = (0, compiler_1.getMinimumCompilerInput)(buildInfo.input, metadata);
            const iface = new ethers_1.ethers.Interface(abi);
            const encodedConstructorArgs = iface.encodeDeploy(constructorArgs);
            await (0, exports.attemptVerification)(expectedAddress, encodedConstructorArgs, `${sourceName}:${contractName}`, buildInfo.solcLongVersion, minimumCompilerInput, provider, String(chainId), etherscanApiKey);
        }
        logger.info('[Sphinx]: finished attempting to verify the sphinx contracts on etherscan');
    }
    catch (e) {
        console.error(e);
        logger.error(`[Sphinx]: error: failed to verify sphinx contracts for ${networkName} on etherscan`, e);
    }
};
exports.verifySphinxSystem = verifySphinxSystem;
exports.builtinChains = [
    {
        network: 'mainnet',
        chainId: 1,
        urls: {
            apiURL: 'https://api.etherscan.io/api',
            browserURL: 'https://etherscan.io',
        },
    },
    {
        network: 'goerli',
        chainId: 5,
        urls: {
            apiURL: 'https://api-goerli.etherscan.io/api',
            browserURL: 'https://goerli.etherscan.io',
        },
    },
    {
        network: 'optimisticEthereum',
        chainId: 10,
        urls: {
            apiURL: 'https://api-optimistic.etherscan.io/api',
            browserURL: 'https://optimistic.etherscan.io/',
        },
    },
    {
        network: 'bsc',
        chainId: 56,
        urls: {
            apiURL: 'https://api.bscscan.com/api',
            browserURL: 'https://bscscan.com',
        },
    },
    {
        network: 'sokol',
        chainId: 77,
        urls: {
            apiURL: 'https://blockscout.com/poa/sokol/api',
            browserURL: 'https://blockscout.com/poa/sokol',
        },
    },
    {
        network: 'bscTestnet',
        chainId: 97,
        urls: {
            apiURL: 'https://api-testnet.bscscan.com/api',
            browserURL: 'https://testnet.bscscan.com',
        },
    },
    {
        network: 'xdai',
        chainId: 100,
        urls: {
            apiURL: 'https://api.gnosisscan.io/api',
            browserURL: 'https://gnosisscan.io',
        },
    },
    {
        network: 'gnosis',
        chainId: 100,
        urls: {
            apiURL: 'https://api.gnosisscan.io/api',
            browserURL: 'https://gnosisscan.io',
        },
    },
    {
        network: 'heco',
        chainId: 128,
        urls: {
            apiURL: 'https://api.hecoinfo.com/api',
            browserURL: 'https://hecoinfo.com',
        },
    },
    {
        network: 'polygon',
        chainId: 137,
        urls: {
            apiURL: 'https://api.polygonscan.com/api',
            browserURL: 'https://polygonscan.com',
        },
    },
    {
        network: 'opera',
        chainId: 250,
        urls: {
            apiURL: 'https://api.ftmscan.com/api',
            browserURL: 'https://ftmscan.com',
        },
    },
    {
        network: 'hecoTestnet',
        chainId: 256,
        urls: {
            apiURL: 'https://api-testnet.hecoinfo.com/api',
            browserURL: 'https://testnet.hecoinfo.com',
        },
    },
    {
        network: 'optimisticGoerli',
        chainId: 420,
        urls: {
            apiURL: 'https://api-goerli-optimism.etherscan.io/api',
            browserURL: 'https://goerli-optimism.etherscan.io/',
        },
    },
    {
        network: 'polygonZkEVM',
        chainId: 1101,
        urls: {
            apiURL: 'https://api-zkevm.polygonscan.com/api',
            browserURL: 'https://zkevm.polygonscan.com',
        },
    },
    {
        network: 'moonbeam',
        chainId: 1284,
        urls: {
            apiURL: 'https://api-moonbeam.moonscan.io/api',
            browserURL: 'https://moonbeam.moonscan.io',
        },
    },
    {
        network: 'moonriver',
        chainId: 1285,
        urls: {
            apiURL: 'https://api-moonriver.moonscan.io/api',
            browserURL: 'https://moonriver.moonscan.io',
        },
    },
    {
        network: 'moonbaseAlpha',
        chainId: 1287,
        urls: {
            apiURL: 'https://api-moonbase.moonscan.io/api',
            browserURL: 'https://moonbase.moonscan.io/',
        },
    },
    {
        network: 'polygonZkEVMTestnet',
        chainId: 1442,
        urls: {
            apiURL: 'https://api-testnet-zkevm.polygonscan.com/api',
            browserURL: 'https://testnet-zkevm.polygonscan.com',
        },
    },
    {
        network: 'ftmTestnet',
        chainId: 4002,
        urls: {
            apiURL: 'https://api-testnet.ftmscan.com/api',
            browserURL: 'https://testnet.ftmscan.com',
        },
    },
    {
        network: 'base',
        chainId: 8453,
        urls: {
            apiURL: 'https://api.basescan.org/api',
            browserURL: 'https://basescan.org/',
        },
    },
    {
        network: 'chiado',
        chainId: 10200,
        urls: {
            apiURL: 'https://gnosis-chiado.blockscout.com/api',
            browserURL: 'https://gnosis-chiado.blockscout.com',
        },
    },
    {
        network: 'arbitrumOne',
        chainId: 42161,
        urls: {
            apiURL: 'https://api.arbiscan.io/api',
            browserURL: 'https://arbiscan.io/',
        },
    },
    {
        network: 'avalancheFujiTestnet',
        chainId: 43113,
        urls: {
            apiURL: 'https://api-testnet.snowtrace.io/api',
            browserURL: 'https://testnet.snowtrace.io/',
        },
    },
    {
        network: 'avalanche',
        chainId: 43114,
        urls: {
            apiURL: 'https://api.snowtrace.io/api',
            browserURL: 'https://snowtrace.io/',
        },
    },
    {
        network: 'polygonMumbai',
        chainId: 80001,
        urls: {
            apiURL: 'https://api-testnet.polygonscan.com/api',
            browserURL: 'https://mumbai.polygonscan.com/',
        },
    },
    {
        network: 'baseGoerli',
        chainId: 84531,
        urls: {
            apiURL: 'https://api-goerli.basescan.org/api',
            browserURL: 'https://goerli.basescan.org/',
        },
    },
    {
        network: 'arbitrumTestnet',
        chainId: 421611,
        urls: {
            apiURL: 'https://api-testnet.arbiscan.io/api',
            browserURL: 'https://testnet.arbiscan.io/',
        },
    },
    {
        network: 'arbitrumGoerli',
        chainId: 421613,
        urls: {
            apiURL: 'https://api-goerli.arbiscan.io/api',
            browserURL: 'https://goerli.arbiscan.io/',
        },
    },
    {
        network: 'sepolia',
        chainId: 11155111,
        urls: {
            apiURL: 'https://api-sepolia.etherscan.io/api',
            browserURL: 'https://sepolia.etherscan.io',
        },
    },
    {
        network: 'aurora',
        chainId: 1313161554,
        urls: {
            apiURL: 'https://explorer.mainnet.aurora.dev/api',
            browserURL: 'https://explorer.mainnet.aurora.dev',
        },
    },
    {
        network: 'auroraTestnet',
        chainId: 1313161555,
        urls: {
            apiURL: 'https://explorer.testnet.aurora.dev/api',
            browserURL: 'https://explorer.testnet.aurora.dev',
        },
    },
    {
        network: 'harmony',
        chainId: 1666600000,
        urls: {
            apiURL: 'https://ctrver.t.hmny.io/verify',
            browserURL: 'https://explorer.harmony.one',
        },
    },
    {
        network: 'harmonyTest',
        chainId: 1666700000,
        urls: {
            apiURL: 'https://ctrver.t.hmny.io/verify?network=testnet',
            browserURL: 'https://explorer.pops.one',
        },
    },
];
//# sourceMappingURL=etherscan.js.map