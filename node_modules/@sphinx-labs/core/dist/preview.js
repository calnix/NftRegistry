"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPreview = exports.getPreviewString = exports.isDecodedAction = void 0;
const chalk_1 = require("chalk");
const contracts_1 = require("@sphinx-labs/contracts");
const types_1 = require("./config/types");
const utils_1 = require("./utils");
const networks_1 = require("./networks");
const errors_1 = require("./errors");
const isDecodedAction = (element) => element.referenceName !== undefined &&
    element.functionName !== undefined &&
    element.variables !== undefined;
exports.isDecodedAction = isDecodedAction;
const getPreviewString = (preview, includeConfirmQuestion) => {
    let previewString = '';
    const skippingReason = `${chalk_1.yellow.bold(`Reason:`)} ${(0, chalk_1.yellow)(`Already executed.`)}`;
    for (const { networkTags, executing, skipping, chainId, safeAddress, } of preview.networks) {
        const networkTagsArray = [];
        if (networkTags.length === 1) {
            networkTagsArray.push(`${(0, chalk_1.bold)(`Network:`)} ${networkTags[0]}`);
        }
        else {
            networkTagsArray.push(chalk_1.bold.underline(`Networks:`));
            const networks = networkTags.map((tag, i) => `${i + 1}. ${tag}`);
            networkTagsArray.push(...networks);
        }
        previewString += `${networkTagsArray.join('\n')}\n`;
        const executingArray = [];
        if (executing.length === 0) {
            executingArray.push(chalk_1.green.underline.bold(`Nothing to execute.`));
        }
        else {
            executingArray.push(chalk_1.green.underline.bold(`Executing:`));
            for (let i = 0; i < executing.length; i++) {
                const element = executing[i];
                if ((0, exports.isDecodedAction)(element)) {
                    const { referenceName, functionName, variables, address, value } = element;
                    const actionStr = (0, utils_1.prettyFunctionCall)(referenceName, address, functionName, variables, chainId, value, 5, 3);
                    executingArray.push((0, chalk_1.green)(`${i + 1}. ${actionStr}`));
                }
                else if (isSystemDeploymentElement(element)) {
                    executingArray.push((0, chalk_1.green)(`${i + 1}. Sphinx & Gnosis Safe Contracts`));
                }
                else if (isFundingSafeElement(element)) {
                    const actionStr = (0, utils_1.prettyFunctionCall)('GnosisSafe', safeAddress, 'call', {}, chainId, element.value, 5, 3);
                    executingArray.push((0, chalk_1.green)(`${i + 1}. ${actionStr}`));
                }
                else {
                    const { to, data } = element;
                    const actionStr = (0, utils_1.prettyRawFunctionCall)(to, data);
                    executingArray.push((0, chalk_1.green)(`${i + 1}. ${actionStr}`));
                }
            }
        }
        previewString += `${executingArray.join('\n')}\n`;
        if (skipping.length > 0) {
            const skippingArray = [];
            skippingArray.push(chalk_1.yellow.underline.bold(`Skipping:`));
            skippingArray.push(skippingReason);
            for (let i = 0; i < skipping.length; i++) {
                const element = skipping[i];
                let functionCallStr;
                if ((0, exports.isDecodedAction)(element)) {
                    functionCallStr = (0, utils_1.prettyFunctionCall)(element.referenceName, element.address, element.functionName, element.variables, chainId, element.value, 5, 3);
                }
                else if (isSystemDeploymentElement(element)) {
                    throw new Error(`Skipped preview elements contain the Sphinx system contracts. Should never happen.`);
                }
                else if (isFundingSafeElement(element)) {
                    throw new errors_1.InvariantError(`Skipped preview elements contain a Safe funding element`);
                }
                else {
                    functionCallStr = (0, utils_1.prettyRawFunctionCall)(element.to, element.data);
                }
                const skippingStr = (0, chalk_1.yellow)(`${i + 1}. ${functionCallStr}`);
                skippingArray.push(skippingStr);
            }
            previewString += `${skippingArray.join('\n')}\n`;
        }
        previewString += '\n';
    }
    if (preview.unlabeledAddresses.size > 0) {
        previewString += `${chalk_1.yellow.bold(`Warning: Sphinx couldn't find a contract artifact for the following addresses:\n`)}`;
        previewString += `${Array.from(preview.unlabeledAddresses)
            .map((e) => (0, chalk_1.yellow)(`- ${e}`))
            .join('\n')}\n`;
        previewString += (0, chalk_1.yellow)(`This typically happens when deploying contracts using hardcoded bytecode and no \n` +
            `associated source file. Sphinx will not create a deployment artifact or attempt \n` +
            `Etherscan verification for any address in the list above.\n\n` +
            `If you think this is a mistake, try running "forge build --force", then run your Sphinx command again.\n`);
    }
    if (includeConfirmQuestion) {
        previewString += `Confirm? [y/n]`;
    }
    return previewString;
};
exports.getPreviewString = getPreviewString;
const assertIsFundingCheckAction = (fundingCheck, fundingRequest, safeAddress) => {
    const expectedCheckValue = (BigInt(fundingRequest.fundsRequested) +
        BigInt(fundingRequest.startingBalance)).toString();
    if (!fundingCheck ||
        fundingCheck.txData !== '0x' ||
        fundingCheck.value !== expectedCheckValue ||
        fundingCheck.to !== safeAddress ||
        fundingCheck.actionType !== types_1.ActionInputType.CALL ||
        fundingCheck.requireSuccess !== true ||
        fundingCheck.operation !== contracts_1.Operation.Call ||
        fundingCheck.contracts.length !== 0 ||
        fundingCheck.index !== '1' ||
        fundingCheck.decodedAction.address !== '' ||
        fundingCheck.decodedAction.functionName !== 'call' ||
        fundingCheck.decodedAction.referenceName !== safeAddress ||
        fundingCheck.decodedAction.value !== expectedCheckValue ||
        !Array.isArray(fundingCheck.decodedAction.variables) ||
        fundingCheck.decodedAction.variables?.length !== 1 ||
        fundingCheck.decodedAction.variables[0] !== '0x') {
        throw new errors_1.InvariantError('Expected to find Gnosis Safe funding checking action, but did not');
    }
};
const getPreview = (networkConfigs) => {
    const networks = {};
    for (const networkConfig of networkConfigs) {
        const executing = [];
        const skipping = [];
        const { chainId, initialState, actionInputs, executionMode, unlabeledContracts, isSystemDeployed, } = networkConfig;
        const unlabeledAddresses = unlabeledContracts
            .filter((contract) => contract.initCodeWithArgs !== contracts_1.CREATE3_PROXY_INITCODE)
            .map((contract) => contract.address);
        const networkName = (0, networks_1.fetchNameForNetwork)(BigInt(chainId));
        const networkTag = (0, utils_1.getNetworkTag)(networkName, executionMode, BigInt(chainId));
        if (actionInputs.length > 0) {
            if (!isSystemDeployed) {
                executing.push({
                    type: 'SystemDeployment',
                });
            }
            if (!initialState.isSafeDeployed) {
                executing.push({
                    referenceName: 'GnosisSafe',
                    functionName: 'deploy',
                    variables: {},
                    address: networkConfig.safeAddress,
                    value: '0',
                });
            }
            if (!initialState.isModuleDeployed) {
                executing.push({
                    referenceName: 'SphinxModule',
                    functionName: 'deploy',
                    variables: {},
                    address: networkConfig.moduleAddress,
                    value: '0',
                });
            }
            for (let i = 0; i < actionInputs.length; i++) {
                if (i === 0 &&
                    networkConfig.safeFundingRequest &&
                    BigInt(networkConfig.safeFundingRequest.fundsRequested) > BigInt(0)) {
                    const [fundingCheck] = actionInputs;
                    assertIsFundingCheckAction(fundingCheck, networkConfig.safeFundingRequest, networkConfig.safeAddress);
                    executing.push({
                        type: 'FundingSafe',
                        value: networkConfig.safeFundingRequest.fundsRequested,
                    });
                }
                else {
                    const { decodedAction } = actionInputs[i];
                    executing.push(decodedAction);
                }
            }
        }
        networks[networkTag] = {
            executing,
            skipping,
            unlabeledAddresses,
            chainId: networkConfig.chainId,
            safeAddress: networkConfig.safeAddress,
        };
    }
    const preview = {
        networks: [],
        unlabeledAddresses: new Set([]),
    };
    for (const [networkTag, { executing, skipping, unlabeledAddresses, chainId, safeAddress },] of Object.entries(networks)) {
        const existingNetwork = preview.networks.find((e) => (0, utils_1.arraysEqual)(e.executing, executing) && (0, utils_1.arraysEqual)(e.skipping, skipping));
        for (const address of unlabeledAddresses) {
            preview.unlabeledAddresses.add(address);
        }
        if (existingNetwork) {
            existingNetwork.networkTags.push(networkTag);
        }
        else {
            preview.networks.push({
                networkTags: [networkTag],
                executing,
                skipping,
                chainId,
                safeAddress,
            });
        }
    }
    return preview;
};
exports.getPreview = getPreview;
const isSystemDeploymentElement = (element) => {
    return element.type === 'SystemDeployment';
};
const isFundingSafeElement = (element) => {
    return element.type === 'FundingSafe';
};
//# sourceMappingURL=preview.js.map