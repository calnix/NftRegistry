"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCompilerInputDirName = exports.isReceiptEarlier = exports.isExecutionArtifact = exports.makeDeploymentArtifacts = exports.isContractDeploymentArtifact = exports.isContractDeploymentArtifactExceptHistory = exports.writeDeploymentArtifacts = exports.makeContractDeploymentArtifacts = exports.convertEthersTransactionReceipt = exports.isSphinxTransactionReceipt = exports.isSphinxTransactionResponse = exports.convertEthersTransactionResponse = exports.fetchDeploymentArtifacts = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const ethers_1 = require("ethers");
const contracts_1 = require("@sphinx-labs/contracts");
const axios_1 = __importDefault(require("axios"));
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const fetchDeploymentArtifacts = async (apiKey, orgId, projectName) => {
    const response = await axios_1.default
        .post(`${(0, utils_1.fetchSphinxManagedBaseUrl)()}/api/artifacts`, {
        apiKey,
        orgId,
        projectName,
        viaPresignedUrl: true,
    })
        .catch((err) => {
        if (err.response) {
            if (err.response.status === 400) {
                throw new Error('Malformed request fetching deployment artifacts, please report this to the developers');
            }
            else if (err.response.status === 401) {
                throw new Error(`Unauthorized, please check your API key and Org Id are correct`);
            }
            else if (err.response.status === 404) {
                throw new Error(`No artifacts found for this project`);
            }
            else {
                throw new Error(`Unexpected response code, please report this to the developers`);
            }
        }
        else {
            throw err;
        }
    });
    const artifact = await axios_1.default.get(response.data);
    return artifact.data;
};
exports.fetchDeploymentArtifacts = fetchDeploymentArtifacts;
const convertEthersTransactionResponse = (response, chainId) => {
    if (response === null) {
        throw new Error(`Transaction response is null.`);
    }
    if (!response.blockNumber || !response.blockHash || !response.to) {
        throw new Error(`Invalid field(s) in Ethers transaction response.`);
    }
    const convertedResponse = {
        accessList: response.accessList,
        blockNumber: response.blockNumber,
        blockHash: response.blockHash,
        chainId,
        data: response.data,
        from: response.from,
        gasLimit: response.gasLimit.toString(),
        gasPrice: response.gasPrice.toString(),
        hash: response.hash,
        maxFeePerGas: response.maxFeePerGas?.toString() ?? null,
        maxPriorityFeePerGas: response.maxPriorityFeePerGas?.toString() ?? null,
        nonce: response.nonce,
        signature: {
            networkV: response.signature.networkV?.toString() ?? null,
            r: response.signature.r,
            s: response.signature.s,
            v: response.signature.v,
        },
        to: response.to,
        type: response.type,
        value: response.value.toString(),
    };
    if (!(0, exports.isSphinxTransactionResponse)(convertedResponse)) {
        throw new Error(`SphinxTransactionResponse is invalid.`);
    }
    return convertedResponse;
};
exports.convertEthersTransactionResponse = convertEthersTransactionResponse;
const isSphinxTransactionResponse = (response) => {
    const isValidAccessListEntry = (entry) => typeof entry.address === 'string' &&
        Array.isArray(entry.storageKeys) &&
        entry.storageKeys.every((key) => typeof key === 'string');
    const isValidSignature = (signature) => (typeof signature.networkV === 'string' || signature.networkV === null) &&
        typeof signature.r === 'string' &&
        typeof signature.s === 'string' &&
        (signature.v === 27 || signature.v === 28);
    return (((Array.isArray(response.accessList) &&
        response.accessList.every(isValidAccessListEntry)) ||
        response.accessList === null) &&
        typeof response.blockNumber === 'number' &&
        typeof response.blockHash === 'string' &&
        typeof response.chainId === 'string' &&
        typeof response.data === 'string' &&
        typeof response.from === 'string' &&
        typeof response.gasLimit === 'string' &&
        typeof response.gasPrice === 'string' &&
        typeof response.hash === 'string' &&
        (typeof response.maxFeePerGas === 'string' ||
            response.maxFeePerGas === null) &&
        (typeof response.maxPriorityFeePerGas === 'string' ||
            response.maxPriorityFeePerGas === null) &&
        typeof response.nonce === 'number' &&
        isValidSignature(response.signature) &&
        typeof response.to === 'string' &&
        typeof response.type === 'number' &&
        typeof response.value === 'string');
};
exports.isSphinxTransactionResponse = isSphinxTransactionResponse;
const isSphinxTransactionReceipt = (receipt) => {
    const isValidLogEntry = (log) => typeof log.address === 'string' &&
        typeof log.blockHash === 'string' &&
        typeof log.blockNumber === 'number' &&
        typeof log.data === 'string' &&
        typeof log.index === 'number' &&
        Array.isArray(log.topics) &&
        log.topics.every((topic) => typeof topic === 'string') &&
        typeof log.transactionHash === 'string' &&
        typeof log.transactionIndex === 'number';
    return (typeof receipt.blockHash === 'string' &&
        typeof receipt.blockNumber === 'number' &&
        receipt.contractAddress === null &&
        typeof receipt.cumulativeGasUsed === 'string' &&
        typeof receipt.from === 'string' &&
        typeof receipt.gasPrice === 'string' &&
        typeof receipt.gasUsed === 'string' &&
        typeof receipt.hash === 'string' &&
        typeof receipt.index === 'number' &&
        Array.isArray(receipt.logs) &&
        receipt.logs.every(isValidLogEntry) &&
        typeof receipt.logsBloom === 'string' &&
        (typeof receipt.status === 'number' || receipt.status === null) &&
        typeof receipt.to === 'string' &&
        !ethers_1.ethers.isHexString(receipt.cumulativeGasUsed) &&
        !ethers_1.ethers.isHexString(receipt.gasPrice) &&
        !ethers_1.ethers.isHexString(receipt.gasUsed));
};
exports.isSphinxTransactionReceipt = isSphinxTransactionReceipt;
const convertEthersTransactionReceipt = (receipt) => {
    if (receipt === null) {
        throw new Error(`Transaction response is null.`);
    }
    if (!receipt.to) {
        throw new Error(`Ethers transaction receipt is missing 'to' field.`);
    }
    const converted = {
        blockHash: receipt.blockHash,
        blockNumber: receipt.blockNumber,
        contractAddress: null,
        cumulativeGasUsed: receipt.cumulativeGasUsed.toString(),
        from: receipt.from,
        gasPrice: receipt.gasPrice.toString(),
        gasUsed: receipt.gasUsed.toString(),
        hash: receipt.hash,
        index: receipt.index,
        logs: receipt.logs.map((l) => ({
            address: l.address,
            blockHash: l.blockHash,
            blockNumber: l.blockNumber,
            data: l.data,
            index: l.index,
            topics: [...l.topics],
            transactionHash: l.transactionHash,
            transactionIndex: l.transactionIndex,
        })),
        logsBloom: receipt.logsBloom,
        status: receipt.status,
        to: receipt.to,
    };
    if (!(0, exports.isSphinxTransactionReceipt)(converted)) {
        throw new Error(`SphinxTransactionReceipt is invalid.`);
    }
    return converted;
};
exports.convertEthersTransactionReceipt = convertEthersTransactionReceipt;
const makeContractDeploymentArtifacts = async (merkleRoot, networkConfig, buildInfos, receipts, configArtifacts, artifacts, provider) => {
    const isSuffixed = Object.keys(artifacts).every((fileName) => fileName.endsWith('.json'));
    if (!isSuffixed) {
        throw new Error(`Previous contract deployment artifact file name(s) not suffixed with '.json'`);
    }
    const coder = ethers_1.ethers.AbiCoder.defaultAbiCoder();
    const moduleInterface = new ethers_1.ethers.Interface(contracts_1.SphinxModuleABI);
    const { gitCommit, chainId } = networkConfig;
    const numDeployments = {};
    for (const action of networkConfig.actionInputs) {
        for (const contract of action.contracts) {
            const { fullyQualifiedName, initCodeWithArgs, address } = contract;
            const { artifact: compilerArtifact, buildInfoId } = configArtifacts[fullyQualifiedName];
            const buildInfo = buildInfos[buildInfoId];
            if (!compilerArtifact || !buildInfo) {
                throw new Error(`Could not find artifact for: ${fullyQualifiedName}`);
            }
            const { bytecode, abi, metadata, contractName, sourceName, linkReferences, deployedLinkReferences, } = compilerArtifact;
            const { devdoc, userdoc } = metadata.output;
            const iface = new ethers_1.ethers.Interface(abi);
            const deployedBytecode = await provider.getCode(address);
            if (deployedBytecode === '0x') {
                continue;
            }
            const receipt = receipts.find((rcpt) => rcpt.logs
                .filter((log) => log.address === networkConfig.moduleAddress)
                .some((log) => {
                const parsedLog = moduleInterface.parseLog(log);
                return (parsedLog !== null &&
                    parsedLog.name === 'SphinxActionSucceeded' &&
                    parsedLog.args[0] === merkleRoot &&
                    parsedLog.args[1].toString() === action.index);
            }));
            if (!receipt) {
                throw new Error(`Could not find transaction receipt for: ${address}.`);
            }
            const encodedConstructorArgs = ethers_1.ethers.dataSlice(initCodeWithArgs, ethers_1.ethers.dataLength(bytecode));
            const constructorFragment = iface.fragments.find(ethers_1.ConstructorFragment.isFragment);
            const constructorArgValues = constructorFragment
                ? coder
                    .decode(constructorFragment.inputs, encodedConstructorArgs)
                    .toArray()
                : [];
            const artifact = {
                _format: 'sphinx-sol-ct-artifact-1',
                merkleRoot,
                contractName,
                address,
                abi,
                solcInputHash: buildInfo.id,
                receipt,
                metadata: JSON.stringify(metadata),
                args: constructorArgValues,
                bytecode,
                deployedBytecode,
                devdoc,
                userdoc,
                gitCommit,
                sourceName,
                chainId,
                linkReferences,
                deployedLinkReferences,
                history: [],
            };
            const previousNumDeployments = numDeployments[contractName] ?? 0;
            const fileName = previousNumDeployments > 0
                ? `${contractName}_${previousNumDeployments}.json`
                : `${contractName}.json`;
            const previousArtifact = artifacts[fileName];
            if (previousArtifact) {
                const { history: previousHistory, ...previousArtifactWithoutHistory } = previousArtifact;
                artifact.history = previousHistory.concat(previousArtifactWithoutHistory);
            }
            if (!(0, exports.isContractDeploymentArtifact)(artifact)) {
                throw new Error(`Contract deployment artifact is invalid.`);
            }
            artifacts[fileName] = artifact;
            numDeployments[contractName] = previousNumDeployments + 1;
        }
    }
};
exports.makeContractDeploymentArtifacts = makeContractDeploymentArtifacts;
const writeDeploymentArtifacts = (projectName, executionMode, deploymentArtifacts) => {
    const rootArtifactDirPath = (0, path_1.resolve)('deployments');
    const projectDirPath = (0, path_1.join)(rootArtifactDirPath, projectName);
    const compilerInputDirPath = (0, path_1.join)(rootArtifactDirPath, (0, exports.getCompilerInputDirName)(executionMode));
    if (!(0, fs_1.existsSync)(projectDirPath)) {
        (0, fs_1.mkdirSync)(projectDirPath, { recursive: true });
    }
    if (!(0, fs_1.existsSync)(compilerInputDirPath)) {
        (0, fs_1.mkdirSync)(compilerInputDirPath);
    }
    for (const chainId of Object.keys(deploymentArtifacts.networks)) {
        const { executionArtifacts, contractDeploymentArtifacts } = deploymentArtifacts.networks[chainId];
        const networkDirPath = (0, path_1.join)(projectDirPath, (0, utils_1.getNetworkNameDirectory)(chainId, executionMode));
        const executionDirPath = (0, path_1.join)(networkDirPath, 'execution');
        if (!(0, fs_1.existsSync)(executionDirPath)) {
            (0, fs_1.mkdirSync)(executionDirPath, { recursive: true });
        }
        for (const [fileName, executionArtifact] of Object.entries(executionArtifacts)) {
            const transactionFilePath = (0, path_1.join)(executionDirPath, fileName);
            (0, fs_1.writeFileSync)(transactionFilePath, JSON.stringify(executionArtifact, null, '\t'));
        }
        for (const [fileName, contractArtifact] of Object.entries(contractDeploymentArtifacts)) {
            const contractArtifactFilePath = (0, path_1.join)(networkDirPath, fileName);
            (0, fs_1.writeFileSync)(contractArtifactFilePath, JSON.stringify(contractArtifact, null, '\t'));
        }
    }
    for (const [fileName, compilerInput] of Object.entries(deploymentArtifacts.compilerInputs)) {
        const filePath = (0, path_1.join)(compilerInputDirPath, fileName);
        if (!(0, fs_1.existsSync)(filePath)) {
            (0, fs_1.writeFileSync)(filePath, JSON.stringify(compilerInput, null, '\t'));
        }
    }
};
exports.writeDeploymentArtifacts = writeDeploymentArtifacts;
const isContractDeploymentArtifactExceptHistory = (item) => {
    return (item !== null &&
        typeof item === 'object' &&
        item._format === 'sphinx-sol-ct-artifact-1' &&
        typeof item.merkleRoot === 'string' &&
        typeof item.address === 'string' &&
        typeof item.sourceName === 'string' &&
        typeof item.contractName === 'string' &&
        typeof item.chainId === 'string' &&
        (0, exports.isSphinxTransactionReceipt)(item.receipt) &&
        Array.isArray(item.args) &&
        typeof item.solcInputHash === 'string' &&
        Array.isArray(item.abi) &&
        typeof item.bytecode === 'string' &&
        typeof item.deployedBytecode === 'string' &&
        (0, contracts_1.isLinkReferences)(item.linkReferences) &&
        (0, contracts_1.isLinkReferences)(item.deployedLinkReferences) &&
        typeof item.metadata === 'string' &&
        (typeof item.gitCommit === 'string' || item.gitCommit === null) &&
        (typeof item.devdoc === 'object' || item.devdoc === undefined) &&
        (typeof item.userdoc === 'object' || item.userdoc === undefined));
};
exports.isContractDeploymentArtifactExceptHistory = isContractDeploymentArtifactExceptHistory;
const isContractDeploymentArtifact = (obj) => {
    return ((0, exports.isContractDeploymentArtifactExceptHistory)(obj) &&
        Array.isArray(obj.history) &&
        obj.history.every((hist) => (0, exports.isContractDeploymentArtifactExceptHistory)(hist) &&
            hist.history === undefined));
};
exports.isContractDeploymentArtifact = isContractDeploymentArtifact;
const makeDeploymentArtifacts = async (deployments, merkleRoot, configArtifacts, artifacts) => {
    const { networks: allNetworkArtifacts, compilerInputs: compilerInputArtifacts, } = artifacts;
    for (const chainId of Object.keys(deployments)) {
        const { provider, deploymentConfig, receipts } = deployments[chainId];
        if (allNetworkArtifacts[chainId] === undefined) {
            allNetworkArtifacts[chainId] = {
                contractDeploymentArtifacts: {},
                executionArtifacts: {},
            };
        }
        const networkConfig = (0, utils_1.fetchNetworkConfigFromDeploymentConfig)(BigInt(chainId), deploymentConfig);
        await (0, exports.makeContractDeploymentArtifacts)(merkleRoot, networkConfig, deploymentConfig.buildInfos, receipts, configArtifacts, allNetworkArtifacts[chainId].contractDeploymentArtifacts, provider);
        const executionArtifact = await makeExecutionArtifact(receipts, deploymentConfig, networkConfig, merkleRoot, provider);
        allNetworkArtifacts[chainId].executionArtifacts[`${(0, contracts_1.remove0x)(merkleRoot)}.json`] = executionArtifact;
        for (const compilerInput of deploymentConfig.inputs) {
            compilerInputArtifacts[`${compilerInput.id}.json`] = compilerInput;
        }
    }
};
exports.makeDeploymentArtifacts = makeDeploymentArtifacts;
const makeExecutionArtifact = async (receipts, deploymentConfig, networkConfig, merkleRoot, provider) => {
    const ethersResponses = await Promise.all(receipts.map((rcpt) => provider.getTransaction(rcpt.hash)));
    const responses = ethersResponses.map((ethersResponse) => (0, exports.convertEthersTransactionResponse)(ethersResponse, networkConfig.chainId));
    const transactions = responses.map((response, i) => {
        return { receipt: receipts[i], response };
    });
    transactions.sort((a, b) => {
        if ((0, exports.isReceiptEarlier)(a.receipt, b.receipt)) {
            return -1;
        }
        else if ((0, exports.isReceiptEarlier)(b.receipt, a.receipt)) {
            return 1;
        }
        return 0;
    });
    const solcInputHashes = deploymentConfig.inputs.map((input) => input.id);
    const { safeAddress, moduleAddress, executorAddress, nonce, chainId, actionInputs, executionMode, unlabeledContracts, arbitraryChain, libraries, gitCommit, } = networkConfig;
    const { owners, threshold, saltNonce, projectName, orgId, mainnets, testnets, } = networkConfig.newConfig;
    const { isExecuting, isModuleDeployed, isSafeDeployed } = networkConfig.initialState;
    const actions = actionInputs.map(utils_1.toSphinxTransaction);
    const safeInitData = networkConfig.initialState.isSafeDeployed
        ? null
        : networkConfig.safeInitData;
    const executionArtifact = {
        _format: 'sphinx-sol-execution-artifact-1',
        transactions,
        merkleRoot,
        solcInputHashes,
        safeAddress,
        moduleAddress,
        executorAddress,
        nonce,
        chainId,
        actions,
        sphinxConfig: {
            projectName,
            orgId,
            owners,
            mainnets,
            testnets,
            threshold,
            saltNonce,
        },
        executionMode,
        initialState: {
            isSafeDeployed,
            isModuleDeployed,
            isExecuting,
        },
        unlabeledContracts,
        arbitraryChain,
        libraries,
        gitCommit,
        safeInitData,
    };
    if (!(0, exports.isExecutionArtifact)(executionArtifact)) {
        throw new Error(`Execution artifact is invalid.`);
    }
    return executionArtifact;
};
const isLibraryArray = (ary) => {
    if (!Array.isArray(ary)) {
        return false;
    }
    return ary.every((item) => {
        if (typeof item !== 'string') {
            return false;
        }
        const parts = item.split(/[:=]/);
        if (parts.length !== 3) {
            return false;
        }
        const address = parts[2];
        return ethers_1.ethers.isAddress(address);
    });
};
const isUnlabeledContracts = (ary) => {
    return (Array.isArray(ary) &&
        ary.every(({ address, initCodeWithArgs }) => ethers_1.ethers.isAddress(address) && typeof initCodeWithArgs === 'string'));
};
const isExecutionArtifact = (obj) => {
    return (obj !== null &&
        typeof obj === 'object' &&
        obj._format === 'sphinx-sol-execution-artifact-1' &&
        Array.isArray(obj.transactions) &&
        obj.transactions.every((tx) => (0, contracts_1.isNonNullObject)(tx) &&
            (0, exports.isSphinxTransactionResponse)(tx.response) &&
            (0, exports.isSphinxTransactionReceipt)(tx.receipt)) &&
        typeof obj.merkleRoot === 'string' &&
        Array.isArray(obj.solcInputHashes) &&
        obj.solcInputHashes.every((hash) => typeof hash === 'string') &&
        typeof obj.safeAddress === 'string' &&
        typeof obj.moduleAddress === 'string' &&
        typeof obj.executorAddress === 'string' &&
        typeof obj.nonce === 'string' &&
        typeof obj.chainId === 'string' &&
        obj.actions.every(utils_1.isSphinxTransaction) &&
        typeof obj.sphinxConfig === 'object' &&
        obj.sphinxConfig !== null &&
        typeof obj.sphinxConfig.projectName === 'string' &&
        typeof obj.sphinxConfig.orgId === 'string' &&
        Array.isArray(obj.sphinxConfig.owners) &&
        obj.sphinxConfig.owners.every((owner) => typeof owner === 'string') &&
        Array.isArray(obj.sphinxConfig.mainnets) &&
        obj.sphinxConfig.mainnets.every((net) => typeof net === 'string') &&
        Array.isArray(obj.sphinxConfig.testnets) &&
        obj.sphinxConfig.testnets.every((net) => typeof net === 'string') &&
        typeof obj.sphinxConfig.threshold === 'string' &&
        typeof obj.sphinxConfig.saltNonce === 'string' &&
        typeof obj.executionMode === 'number' &&
        typeof obj.initialState === 'object' &&
        obj.initialState !== null &&
        typeof obj.initialState.isSafeDeployed === 'boolean' &&
        typeof obj.initialState.isModuleDeployed === 'boolean' &&
        typeof obj.initialState.isExecuting === 'boolean' &&
        isUnlabeledContracts(obj.unlabeledContracts) &&
        typeof obj.arbitraryChain === 'boolean' &&
        isLibraryArray(obj.libraries) &&
        (typeof obj.gitCommit === 'string' || obj.gitCommit === null) &&
        (typeof obj.safeInitData === 'string' || obj.safeInitData === null));
};
exports.isExecutionArtifact = isExecutionArtifact;
const isReceiptEarlier = (receipt1, receipt2) => {
    if (receipt1.blockNumber < receipt2.blockNumber) {
        return true;
    }
    else if (receipt1.blockNumber === receipt2.blockNumber &&
        receipt1.index < receipt2.index) {
        return true;
    }
    return false;
};
exports.isReceiptEarlier = isReceiptEarlier;
const getCompilerInputDirName = (executionMode) => {
    if (executionMode === constants_1.ExecutionMode.LocalNetworkCLI) {
        return 'compiler-inputs-local';
    }
    else if (executionMode === constants_1.ExecutionMode.LiveNetworkCLI ||
        executionMode === constants_1.ExecutionMode.Platform) {
        return 'compiler-inputs';
    }
    else {
        throw new Error(`Unknown execution mode.`);
    }
};
exports.getCompilerInputDirName = getCompilerInputDirName;
//# sourceMappingURL=artifacts.js.map