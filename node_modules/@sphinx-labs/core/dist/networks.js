"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLargestPossibleReorg = exports.shouldUseHigherMaxGasLimit = exports.implementsEIP2028 = exports.shouldBufferExecuteActionsGasLimit = exports.isLegacyTransactionsRequiredForNetwork = exports.fetchURLForNetwork = exports.isLiveNetworkRpcApiKeyDefined = exports.fetchCurrencyForNetwork = exports.fetchEtherscanConfigForNetwork = exports.isVerificationSupportedForNetwork = exports.isBlockscoutSupportedForNetwork = exports.isEtherscanSupportedForNetwork = exports.calculateMerkleLeafGas = exports.fetchDripVersionForNetwork = exports.fetchDecimalsForNetwork = exports.fetchDripSizeForNetwork = exports.isSupportedProductionNetwork = exports.isSupportedTestNetwork = exports.fetchNameForNetwork = exports.fetchChainIdForNetwork = exports.networkEnumToName = exports.COMPILER_CONFIG_VERSION = void 0;
const networks_1 = require("@sphinx-labs/contracts/dist/networks");
exports.COMPILER_CONFIG_VERSION = '0.2.0';
const networkEnumToName = (networkEnum) => {
    const networkEnumBigInt = BigInt(networkEnum);
    const network = networks_1.SPHINX_NETWORKS.find((_, index) => BigInt(index + 1) === networkEnumBigInt);
    if (network) {
        return network.name;
    }
    else {
        throw new Error(`Unsupported network enum ${networkEnum}`);
    }
};
exports.networkEnumToName = networkEnumToName;
const fetchChainIdForNetwork = (networkName) => {
    const network = [...networks_1.SPHINX_NETWORKS, ...networks_1.SPHINX_LOCAL_NETWORKS].find((n) => n.name === networkName);
    if (network) {
        return network.chainId;
    }
    else {
        throw new Error(`Unsupported network name ${networkName}`);
    }
};
exports.fetchChainIdForNetwork = fetchChainIdForNetwork;
const fetchNameForNetwork = (chainId) => {
    const network = [...networks_1.SPHINX_NETWORKS, ...networks_1.SPHINX_LOCAL_NETWORKS].find((n) => n.chainId === chainId);
    if (network) {
        return network.name;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.fetchNameForNetwork = fetchNameForNetwork;
const isSupportedTestNetwork = (chainId) => {
    const network = networks_1.SPHINX_NETWORKS.find((n) => n.chainId === chainId);
    if (network) {
        return network.networkType === 'Testnet';
    }
    else {
        return false;
    }
};
exports.isSupportedTestNetwork = isSupportedTestNetwork;
const isSupportedProductionNetwork = (chainId) => {
    const network = networks_1.SPHINX_NETWORKS.find((n) => n.chainId === chainId);
    if (network) {
        return network.networkType === 'Mainnet';
    }
    else {
        return false;
    }
};
exports.isSupportedProductionNetwork = isSupportedProductionNetwork;
const fetchDripSizeForNetwork = (chainId) => {
    const network = networks_1.SPHINX_NETWORKS.find((n) => n.chainId === chainId);
    if (network) {
        return network.dripSize;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.fetchDripSizeForNetwork = fetchDripSizeForNetwork;
const fetchDecimalsForNetwork = (chainId) => {
    const network = networks_1.SPHINX_NETWORKS.find((n) => n.chainId === chainId);
    if (network) {
        return network.decimals;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.fetchDecimalsForNetwork = fetchDecimalsForNetwork;
const fetchDripVersionForNetwork = (chainId) => {
    const network = networks_1.SPHINX_NETWORKS.find((n) => n.chainId === chainId);
    if (network) {
        return network.dripVersion;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.fetchDripVersionForNetwork = fetchDripVersionForNetwork;
const calculateMerkleLeafGas = (chainId, foundryGas, deployedContractSizes, access) => {
    const network = networks_1.SPHINX_NETWORKS.find((n) => n.chainId === chainId);
    if (network?.handleNetworkSpecificMerkleLeafGas) {
        return network.handleNetworkSpecificMerkleLeafGas(foundryGas, deployedContractSizes, access);
    }
    else {
        return foundryGas;
    }
};
exports.calculateMerkleLeafGas = calculateMerkleLeafGas;
const isEtherscanSupportedForNetwork = (chainId, mockSphinxNetworks) => {
    const networks = mockSphinxNetworks ?? networks_1.SPHINX_NETWORKS;
    const network = networks.find((n) => n.chainId === chainId);
    if (network) {
        return network.blockexplorers.etherscan !== undefined;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.isEtherscanSupportedForNetwork = isEtherscanSupportedForNetwork;
const isBlockscoutSupportedForNetwork = (chainId, mockSphinxNetworks) => {
    const networks = mockSphinxNetworks ?? networks_1.SPHINX_NETWORKS;
    const network = networks.find((n) => n.chainId === chainId);
    if (network) {
        return network.blockexplorers.blockscout !== undefined;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.isBlockscoutSupportedForNetwork = isBlockscoutSupportedForNetwork;
const isVerificationSupportedForNetwork = (chainId, mockSphinxNetworks) => {
    return ((0, exports.isEtherscanSupportedForNetwork)(chainId, mockSphinxNetworks) ||
        (0, exports.isBlockscoutSupportedForNetwork)(chainId, mockSphinxNetworks));
};
exports.isVerificationSupportedForNetwork = isVerificationSupportedForNetwork;
const fetchEtherscanConfigForNetwork = (chainId, explorerName, mockSphinxNetworks) => {
    const networks = mockSphinxNetworks ?? networks_1.SPHINX_NETWORKS;
    const network = networks.find((n) => n.chainId === chainId);
    if (!(0, exports.isVerificationSupportedForNetwork)(chainId, mockSphinxNetworks)) {
        throw new Error(`verification is not supported on network with id: ${chainId}`);
    }
    if (network) {
        if (explorerName) {
            if (explorerName === 'Blockscout') {
                return network.blockexplorers.blockscout;
            }
            else if (explorerName === 'Etherscan') {
                return network.blockexplorers.etherscan;
            }
            else {
                throw new Error('unsupported explorer name, should never happen');
            }
        }
        else {
            if (network.blockexplorers.etherscan) {
                return network.blockexplorers.etherscan;
            }
            else if (network.blockexplorers.blockscout) {
                return network.blockexplorers.blockscout;
            }
            else {
                throw new Error('Failed to find etherscan or blockscout config for network, should never happen');
            }
        }
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.fetchEtherscanConfigForNetwork = fetchEtherscanConfigForNetwork;
const fetchCurrencyForNetwork = (chainId) => {
    const network = [...networks_1.SPHINX_LOCAL_NETWORKS, ...networks_1.SPHINX_NETWORKS].find((n) => n.chainId === chainId);
    if (network) {
        return network.currency;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.fetchCurrencyForNetwork = fetchCurrencyForNetwork;
const isLiveNetworkRpcApiKeyDefined = (chainId) => {
    const network = networks_1.SPHINX_NETWORKS.find((n) => n.chainId === chainId);
    if (!network) {
        return false;
    }
    for (const requiredEnvVariable of network.requiredEnvVariables) {
        if (!process.env[requiredEnvVariable]) {
            return false;
        }
    }
    return true;
};
exports.isLiveNetworkRpcApiKeyDefined = isLiveNetworkRpcApiKeyDefined;
const fetchURLForNetwork = (chainId) => {
    if (process.env.RUNNING_LOCALLY === 'true') {
        return `http://127.0.0.1:${Number(BigInt(42000) + (chainId % BigInt(1000)))}`;
    }
    const CIRCLE_BRANCH = process.env.CIRCLE_BRANCH;
    if (typeof CIRCLE_BRANCH === 'string' && CIRCLE_BRANCH !== 'develop') {
        throw new Error(`You cannot use live network RPC endpoints in CI with a source branch that isn't 'develop'.`);
    }
    const network = networks_1.SPHINX_NETWORKS.find((n) => n.chainId === chainId);
    if (network) {
        for (const requiredEnvVariable of network.requiredEnvVariables) {
            if (!process.env[requiredEnvVariable]) {
                throw new Error(`${requiredEnvVariable} key not defined`);
            }
        }
        return network.rpcUrl();
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.fetchURLForNetwork = fetchURLForNetwork;
const isLegacyTransactionsRequiredForNetwork = (chainId) => {
    const network = [...networks_1.SPHINX_NETWORKS, ...networks_1.SPHINX_LOCAL_NETWORKS].find((n) => n.chainId === chainId);
    if (network) {
        return network.legacyTx ?? false;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.isLegacyTransactionsRequiredForNetwork = isLegacyTransactionsRequiredForNetwork;
const shouldBufferExecuteActionsGasLimit = (chainId) => {
    const network = [...networks_1.SPHINX_NETWORKS, ...networks_1.SPHINX_LOCAL_NETWORKS].find((n) => n.chainId === chainId);
    if (network) {
        return network.actionGasLimitBuffer ?? false;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.shouldBufferExecuteActionsGasLimit = shouldBufferExecuteActionsGasLimit;
const implementsEIP2028 = (chainId) => {
    const network = [...networks_1.SPHINX_NETWORKS, ...networks_1.SPHINX_LOCAL_NETWORKS].find((n) => n.chainId === chainId);
    if (network) {
        return network.eip2028 ?? true;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.implementsEIP2028 = implementsEIP2028;
const shouldUseHigherMaxGasLimit = (chainId) => {
    const network = [...networks_1.SPHINX_NETWORKS, ...networks_1.SPHINX_LOCAL_NETWORKS].find((n) => n.chainId === chainId);
    if (network) {
        return network.useHigherMaxGasLimit ?? false;
    }
    else {
        throw new Error(`Unsupported network id ${chainId}`);
    }
};
exports.shouldUseHigherMaxGasLimit = shouldUseHigherMaxGasLimit;
const getLargestPossibleReorg = (chainIdStr) => {
    const chainId = Number(chainIdStr);
    if (chainId === 1) {
        return BigInt(5);
    }
    if (chainId === 42) {
        return BigInt(5);
    }
    if (chainId === 5) {
        return BigInt(5);
    }
    if (chainId === 4) {
        return BigInt(5);
    }
    if (chainId === 3) {
        return BigInt(100);
    }
    if (chainId === 100) {
        return BigInt(38);
    }
    return BigInt(30);
};
exports.getLargestPossibleReorg = getLargestPossibleReorg;
//# sourceMappingURL=networks.js.map