import { SphinxTransaction, ContractArtifact, SphinxMerkleTree, ParsedAccountAccess, DeployedContractSize } from '@sphinx-labs/contracts';
import { BuildInfo, CompilerInput } from '../languages/solidity/types';
import { SphinxJsonRpcProvider } from '../provider';
import { ParsedContractDeployment } from '../actions/types';
import { ExecutionMode } from '../constants';
export declare const userContractKinds: string[];
export type UserContractKind = 'oz-transparent' | 'oz-ownable-uups' | 'oz-access-control-uups' | 'external-transparent' | 'immutable' | 'proxy';
export declare const contractKindHashes: {
    [contractKind: string]: string;
};
export type Project = string | 'all';
export type ContractKind = UserContractKind | 'proxy';
export declare enum ContractKindEnum {
    INTERNAL_DEFAULT = 0,
    OZ_TRANSPARENT = 1,
    OZ_OWNABLE_UUPS = 2,
    OZ_ACCESS_CONTROL_UUPS = 3,
    EXTERNAL_DEFAULT = 4,
    IMMUTABLE = 5
}
export type ParsedVariable = boolean | string | number | null | Array<ParsedVariable> | {
    [name: string]: ParsedVariable;
};
export type ActionInput = FunctionCallActionInput | Create2ActionInput | CreateActionInput;
export type NetworkConfig = {
    safeAddress: string;
    moduleAddress: string;
    executorAddress: string;
    safeInitData: string;
    nonce: string;
    chainId: string;
    blockGasLimit: string;
    blockNumber: string;
    actionInputs: Array<ActionInput>;
    newConfig: SphinxConfig;
    executionMode: ExecutionMode;
    initialState: InitialChainState;
    isSystemDeployed: boolean;
    unlabeledContracts: Array<{
        address: string;
        initCodeWithArgs: string;
    }>;
    arbitraryChain: boolean;
    libraries: Array<string>;
    gitCommit: string | null;
    safeFundingRequest?: {
        fundsRequested: string;
        startingBalance: string;
    };
};
export type DeploymentInfo = {
    safeAddress: string;
    moduleAddress: string;
    requireSuccess: boolean;
    executorAddress: string;
    nonce: string;
    chainId: string;
    blockGasLimit: string;
    blockNumber: string;
    safeInitData: string;
    newConfig: SphinxConfig;
    executionMode: ExecutionMode;
    initialState: InitialChainState;
    arbitraryChain: boolean;
    sphinxLibraryVersion: string;
    accountAccesses: Array<ParsedAccountAccess>;
    gasEstimates: Array<string>;
    deployedContractSizes: Array<DeployedContractSize>;
    fundsRequestedForSafe: string;
    safeStartingBalance: string;
};
export type InitialChainState = {
    isSafeDeployed: boolean;
    isModuleDeployed: boolean;
    isExecuting: boolean;
};
export type UnsafeAllow = {
    delegatecall?: boolean;
    selfdestruct?: boolean;
    missingPublicUpgradeTo?: boolean;
    emptyPush?: boolean;
    flexibleConstructor?: boolean;
    renames?: boolean;
    skipStorageCheck?: boolean;
};
export type UserAddressOverrides = {
    chains: Array<string>;
    address: string;
};
export type SphinxConfigWithAddresses = SphinxConfig & {
    safeAddress: string;
    moduleAddress: string;
};
export type SphinxConfig = {
    projectName: string;
    orgId: string;
    owners: Array<string>;
    mainnets: Array<string>;
    testnets: Array<string>;
    threshold: string;
    saltNonce: string;
};
export declare enum ActionInputType {
    CREATE = 0,
    CREATE2 = 1,
    CALL = 2
}
export interface Create2ActionInput extends AbstractActionInput {
    create2Address: string;
    initCodeWithArgs: string;
    actionType: ActionInputType.CREATE2;
}
export interface CreateActionInput extends AbstractActionInput {
    contractAddress: string;
    initCodeWithArgs: string;
    actionType: ActionInputType.CREATE;
}
export type DecodedAction = {
    referenceName: string;
    functionName: string;
    variables: ParsedVariable;
    address: string;
    value?: string;
};
export interface FunctionCallActionInput extends AbstractActionInput {
    actionType: ActionInputType.CALL;
}
interface AbstractActionInput extends SphinxTransaction {
    contracts: Array<ParsedContractDeployment>;
    decodedAction: DecodedAction;
    index: string;
}
export interface BuildInfos {
    [id: string]: BuildInfo;
}
export interface DeploymentConfig {
    networkConfigs: Array<NetworkConfig>;
    merkleTree: SphinxMerkleTree;
    configArtifacts: ConfigArtifacts;
    buildInfos: BuildInfos;
    inputs: Array<CompilerInput>;
    version: string;
}
export type ConfigArtifacts = {
    [fullyQualifiedName: string]: {
        buildInfoId: string;
        artifact: ContractArtifact;
    };
};
export type DeploymentRevert = {
    deploymentReverted: boolean;
    revertString?: string;
};
export type ImportCache = {
    requiresImport: boolean;
    currProxyAdmin?: string;
};
export type FoundryContractConfig = {
    referenceName: string;
    addr: string;
    kind: ContractKindEnum;
    userSaltHash: string;
};
export type GetConfigArtifacts = (initCodeWithArgsArray: Array<string>) => Promise<{
    configArtifacts: ConfigArtifacts;
    buildInfos: BuildInfos;
}>;
export type GetProviderForChainId = (chainId: number) => SphinxJsonRpcProvider;
interface AbstractFoundryTransaction {
    transactionType: 'CREATE' | 'CALL' | 'CREATE2';
    contractName: string | null;
    function: string | null;
    arguments: Array<any> | null;
    transaction: {
        type: string | null;
        from: string | null;
        gas: string | null;
        data: string | null;
        nonce: string | null;
        accessList: string | null;
        value?: string | null;
        to?: string | null;
    };
    additionalContracts: Array<{
        transactionType: string;
        address: string;
        initCode: string;
    }>;
    isFixedGasLimit: boolean;
}
export interface FoundryDryRunTransaction extends AbstractFoundryTransaction {
    hash: null;
}
export interface FoundryBroadcastTransaction extends AbstractFoundryTransaction {
    hash: string;
}
export {};
