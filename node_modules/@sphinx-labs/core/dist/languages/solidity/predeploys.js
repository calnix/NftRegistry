"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doDeterministicDeploy = exports.getDeterministicFactoryAddress = exports.deploySphinxSystem = exports.assignManagedServiceRoles = exports.checkSystemDeployed = exports.cancelPreviousDripVersions = exports.ensureSphinxAndGnosisSafeDeployed = void 0;
const console_1 = require("console");
const ethers_1 = require("ethers");
const contracts_1 = require("@sphinx-labs/contracts");
const utils_1 = require("../../utils");
const constants_1 = require("../../constants");
const networks_1 = require("../../networks");
const ensureSphinxAndGnosisSafeDeployed = async (provider, wallet, executionMode, includeManagedServiceRoles, relayers = [], spinner) => {
    if (executionMode === constants_1.ExecutionMode.LocalNetworkCLI ||
        executionMode === constants_1.ExecutionMode.Platform) {
        await (0, utils_1.fundAccountMaxBalance)(wallet.address, provider);
    }
    await (0, exports.deploySphinxSystem)(provider, wallet, relayers, executionMode, includeManagedServiceRoles, spinner);
};
exports.ensureSphinxAndGnosisSafeDeployed = ensureSphinxAndGnosisSafeDeployed;
const cancelPreviousDripVersions = async (Drippie, provider, wallet, executionMode, dripName, currentDripVersion, spinner) => {
    if (currentDripVersion === 0) {
        return;
    }
    else {
        for (let version = 0; version < currentDripVersion; version++) {
            const previousDripName = version === 0 ? dripName : `${dripName}_${version}`;
            const [status] = await Drippie.drips(previousDripName);
            if (status !== BigInt(3) && status !== BigInt(0)) {
                spinner?.start(`Archiving outdated drip: ${previousDripName}...`);
                if (status !== BigInt(1)) {
                    await (await Drippie.status(previousDripName, 1, await (0, utils_1.getGasPriceOverrides)(provider, wallet, executionMode))).wait();
                }
                await (await Drippie.status(previousDripName, 3, await (0, utils_1.getGasPriceOverrides)(provider, wallet, executionMode))).wait();
                spinner?.succeed(`Finished archiving outdated drip: ${previousDripName}`);
            }
        }
    }
};
exports.cancelPreviousDripVersions = cancelPreviousDripVersions;
const checkSystemDeployed = async (provider) => {
    const contracts = (0, contracts_1.getSphinxConstants)();
    const codePromises = contracts.map(({ expectedAddress }) => provider.getCode(expectedAddress));
    const codes = await Promise.all(codePromises);
    return codes.every((code) => code !== '0x');
};
exports.checkSystemDeployed = checkSystemDeployed;
const assignManagedServiceRoles = async (provider, signer, relayers, executionMode, spinner) => {
    let owner;
    const isLiveNetwork_ = await (0, utils_1.isLiveNetwork)(provider);
    if (isLiveNetwork_ && (0, contracts_1.getOwnerAddress)() === contracts_1.OWNER_MULTISIG_ADDRESS) {
        if (!process.env.SPHINX_INTERNAL__OWNER_PRIVATE_KEY) {
            throw new Error('Must define SPHINX_INTERNAL__OWNER_PRIVATE_KEY');
        }
        owner = new ethers_1.ethers.Wallet(process.env.SPHINX_INTERNAL__OWNER_PRIVATE_KEY, provider);
    }
    else {
        if ((0, contracts_1.getOwnerAddress)() === contracts_1.OWNER_MULTISIG_ADDRESS) {
            owner = await (0, utils_1.getImpersonatedSigner)(contracts_1.OWNER_MULTISIG_ADDRESS, provider);
        }
        else {
            owner = new ethers_1.ethers.Wallet(process.env.SPHINX_INTERNAL__OWNER_PRIVATE_KEY, provider);
        }
        if (!isLiveNetwork_) {
            await (await signer.sendTransaction({
                to: await owner.getAddress(),
                value: ethers_1.ethers.parseEther('1'),
            })).wait();
        }
    }
    const ManagedService = new ethers_1.ethers.Contract((0, contracts_1.getManagedServiceAddress)(), contracts_1.ManagedServiceArtifact.abi, owner);
    spinner?.start('Assigning relayers roles...');
    for (const relayer of relayers) {
        if ((await ManagedService.hasRole(constants_1.RELAYER_ROLE, relayer)) === false) {
            await (await ManagedService.grantRole(constants_1.RELAYER_ROLE, relayer, await (0, utils_1.getGasPriceOverrides)(provider, owner, executionMode))).wait();
        }
    }
    spinner?.succeed('Finished assigning relayers roles');
    const Drippie = new ethers_1.ethers.Contract((0, contracts_1.getDrippieAddress)(), contracts_1.DrippieArtifact.abi, owner);
    spinner?.start('Creating relayer drips...');
    for (const relayer of relayers) {
        const chainId = (await provider.getNetwork()).chainId;
        const currentDripVersion = (0, networks_1.fetchDripVersionForNetwork)(chainId);
        const baseDripName = `sphinx_fund_${relayer}`;
        const dripName = baseDripName + (currentDripVersion > 0 ? `_${currentDripVersion}` : '');
        const reentrant = false;
        const interval = 1;
        const dripcheck = (0, contracts_1.getCheckBalanceLowAddress)();
        const checkparams = ethers_1.AbiCoder.defaultAbiCoder().encode(['address', 'uint256'], [
            relayer,
            ethers_1.ethers.parseEther((0, networks_1.fetchDripSizeForNetwork)(chainId)) * BigInt(10),
        ]);
        const actions = [
            {
                target: relayer,
                data: ethers_1.ZeroHash,
                value: ethers_1.ethers.parseUnits((0, networks_1.fetchDripSizeForNetwork)(chainId), (0, networks_1.fetchDecimalsForNetwork)(chainId)),
            },
        ];
        const [status] = await Drippie.drips(dripName);
        if (status === BigInt(2)) {
            spinner?.info(`Drip ${dripName} already exists`);
        }
        else if (status === BigInt(0)) {
            spinner?.start(`Creating drip ${dripName}...`);
            await (await Drippie.create(dripName, {
                reentrant,
                interval,
                dripcheck,
                checkparams,
                actions,
            }, await (0, utils_1.getGasPriceOverrides)(provider, owner, executionMode))).wait();
            await (await Drippie.status(dripName, 2, await (0, utils_1.getGasPriceOverrides)(provider, owner, executionMode))).wait();
        }
        else if (status === BigInt(1)) {
            spinner?.start(`Setting status for drip ${dripName}...`);
            await (await Drippie.status(dripName, 2, await (0, utils_1.getGasPriceOverrides)(provider, owner, executionMode))).wait();
            spinner?.succeed(`Finished setting status for drip ${dripName}`);
        }
        else {
            throw new Error(`Drip ${dripName} has archived status`);
        }
    }
    spinner?.succeed('Finished creating relayer drips');
};
exports.assignManagedServiceRoles = assignManagedServiceRoles;
const deploySphinxSystem = async (provider, signer, relayers, executionMode, includeManagedServiceRoles, spinner) => {
    const block = await provider.getBlock('latest');
    if (!block) {
        throw new Error('Failed to get latest block.');
    }
    for (const { artifact, constructorArgs, expectedAddress, } of (0, contracts_1.getSphinxConstants)()) {
        const { abi, bytecode, contractName } = artifact;
        spinner?.start(`Deploying ${contractName}...`);
        const contract = await (0, exports.doDeterministicDeploy)(provider, executionMode, {
            signer,
            contract: {
                abi,
                bytecode,
            },
            args: constructorArgs,
            salt: ethers_1.ethers.ZeroHash,
        });
        const addr = await contract.getAddress();
        (0, console_1.assert)(addr === expectedAddress, `address mismatch for ${contractName}`);
        spinner?.succeed(`Deployed ${contractName}, ${await contract.getAddress()}`);
    }
    spinner?.succeed(`Finished deploying Sphinx contracts`);
    if (includeManagedServiceRoles) {
        await (0, exports.assignManagedServiceRoles)(provider, signer, relayers, executionMode, spinner);
    }
};
exports.deploySphinxSystem = deploySphinxSystem;
const getDeterministicFactoryAddress = async (provider) => {
    if ((await (0, utils_1.isContractDeployed)(contracts_1.DETERMINISTIC_DEPLOYMENT_PROXY_ADDRESS, provider)) === false) {
        const sender = '0x3fab184622dc19b6109349b94811493bf2a45362';
        try {
            await provider.send('hardhat_setBalance', [
                sender,
                '0xFFFFFFFFFFFFFFFFFFFFFF',
            ]);
        }
        catch {
        }
        try {
            const txnHash = await provider.send('eth_sendRawTransaction', [
                '0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222',
            ]);
            const txn = await provider.getTransaction(txnHash);
            if (!txn) {
                throw new Error(`Failed to deploy CREATE2 factory.`);
            }
            await txn.wait();
        }
        catch (err) {
            if (err.message.includes('insufficient balance')) {
                throw new Error(`insufficient balance to deploy deterministic deployer, please fund the sender: ${sender}`);
            }
            else {
                throw err;
            }
        }
    }
    return contracts_1.DETERMINISTIC_DEPLOYMENT_PROXY_ADDRESS;
};
exports.getDeterministicFactoryAddress = getDeterministicFactoryAddress;
const doDeterministicDeploy = async (provider, executionMode, options) => {
    const factory = new ethers_1.ethers.ContractFactory(options.contract.abi, options.contract.bytecode);
    const deployer = await (0, exports.getDeterministicFactoryAddress)(provider);
    const deploymentTx = await factory.getDeployTransaction(...(options.args || []));
    if (deploymentTx.data === undefined) {
        throw new Error(`Deployment transaction data is undefined`);
    }
    const address = ethers_1.ethers.getCreate2Address(deployer, options.salt, ethers_1.ethers.keccak256(deploymentTx.data));
    if (await (0, utils_1.isContractDeployed)(address, provider)) {
        return new ethers_1.ethers.Contract(address, options.contract.abi, options.signer);
    }
    const txnRequest = await (0, utils_1.getGasPriceOverrides)(provider, options.signer, executionMode, {
        to: deployer,
        data: options.salt + ethers_1.ethers.toBeHex(deploymentTx.data).slice(2),
    });
    await (await options.signer.sendTransaction(txnRequest)).wait();
    if ((await (0, utils_1.isContractDeployed)(address, provider)) === false) {
        throw new Error(`failed to deploy contract at ${address}`);
    }
    return new ethers_1.ethers.Contract(address, options.contract.abi, options.signer);
};
exports.doDeterministicDeploy = doDeterministicDeploy;
//# sourceMappingURL=predeploys.js.map