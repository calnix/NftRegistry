"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findStorageSlotKey = exports.stringifyMerkleRootStatus = exports.stringifyLeafType = exports.findLeafWithProof = exports.getExecuteLeaves = exports.getApproveLeaf = exports.removeGnosisSafeOwnerViaSphinxModule = exports.removeSphinxWalletsFromGnosisSafeOwners = exports.addSphinxWalletsToGnosisSafeOwners = exports.getSphinxWalletPrivateKey = exports.getSphinxWalletsSortedByAddress = exports.toSphinxTransaction = exports.isString = exports.spawnAsync = exports.displayDeploymentTable = exports.elementsEqual = exports.equal = exports.prettyRawFunctionCall = exports.prettyFunctionCall = exports.isSupportedNetworkName = exports.isSupportedChainId = exports.sleep = exports.toHexString = exports.fromHexString = exports.sortHexStrings = exports.isEventLog = exports.getNetworkTag = exports.getNetworkNameDirectory = exports.userConfirmation = exports.arraysEqual = exports.storeDeploymentConfig = exports.relayProposal = exports.fetchSphinxManagedBaseUrl = exports.getDuplicateElements = exports.execAsync = exports.stopImpersonatingAccount = exports.getImpersonatedSigner = exports.isFork = exports.isLiveNetwork = exports.isDataHexString = exports.callWithTimeout = exports.readBuildInfo = exports.isUserContractKind = exports.getGasPriceOverrides = exports.getEIP1967ProxyAdminAddress = exports.getEIP1967ProxyImplementationAddress = exports.formatEther = exports.isContractDeployed = exports.createSphinxLog = exports.sphinxLog = void 0;
exports.sphinxCoreUtils = exports.isPublicAsyncMethod = exports.trimQuotes = exports.hasParentheses = exports.getContractAddressesFromNetworkConfig = exports.isArrayMixed = exports.readDeploymentArtifactsForNetwork = exports.fetchNetworkConfigFromDeploymentConfig = exports.isNormalizedAddress = exports.isFile = exports.isCreateActionInput = exports.isCreate2ActionInput = exports.decodeDeterministicDeploymentProxyData = exports.encodeCreateCall = exports.decodeCall = exports.getAbiEncodedConstructorArgs = exports.isDefined = exports.zeroOutLibraryReferences = exports.getBytesLength = exports.stripLeadingZero = exports.formatSolcLongVersion = exports.getMaxGasLimit = exports.getCreate3Salt = exports.toSphinxLeafWithProofArray = exports.getCreate3Address = exports.getReadableActions = exports.setManagedServiceRelayer = exports.getMappingValueSlotKey = exports.setBalance = exports.fundAccountMaxBalance = exports.signMerkleRoot = exports.isSphinxTransaction = exports.assertValidProjectName = void 0;
const fs = __importStar(require("fs"));
const util_1 = require("util");
const child_process_1 = require("child_process");
const path_1 = require("path");
const fs_1 = require("fs");
const yesno_1 = __importDefault(require("yesno"));
const axios_1 = __importDefault(require("axios"));
const ethers_1 = require("ethers");
const chalk_1 = __importDefault(require("chalk"));
const contracts_1 = require("@sphinx-labs/contracts");
const types_1 = require("./config/types");
const types_2 = require("./actions/types");
const constants_1 = require("./constants");
const provider_1 = require("./provider");
const networks_1 = require("./networks");
const artifacts_1 = require("./artifacts");
const sphinxLog = (logLevel = 'warning', title, lines, silent, stream) => {
    if (silent) {
        return;
    }
    const log = (0, exports.createSphinxLog)(logLevel, title, lines);
    stream.write(log);
};
exports.sphinxLog = sphinxLog;
const createSphinxLog = (logLevel = 'warning', title, lines) => {
    const prefix = logLevel.charAt(0).toUpperCase() + logLevel.slice(1);
    const chalkColor = logLevel === 'warning' ? chalk_1.default.yellow : chalk_1.default.red;
    const parts = ['\n' + chalkColor.bold(prefix + ':') + ' ' + title];
    if (lines.length > 0) {
        parts.push(lines.map((l) => l + '\n').join(''));
    }
    return parts.join('\n') + '\n';
};
exports.createSphinxLog = createSphinxLog;
const isContractDeployed = async (address, provider) => {
    return (await provider.getCode(address)) !== '0x';
};
exports.isContractDeployed = isContractDeployed;
const formatEther = (amount, decimals) => {
    return parseFloat(ethers_1.ethers.formatEther(amount)).toFixed(decimals);
};
exports.formatEther = formatEther;
const getEIP1967ProxyImplementationAddress = async (provider, proxyAddress) => {
    const implStorageKey = '0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc';
    const encodedImplAddress = await provider.getStorage(proxyAddress, implStorageKey);
    const [decoded] = ethers_1.AbiCoder.defaultAbiCoder().decode(['address'], encodedImplAddress);
    return decoded;
};
exports.getEIP1967ProxyImplementationAddress = getEIP1967ProxyImplementationAddress;
const getEIP1967ProxyAdminAddress = async (provider, proxyAddress) => {
    const ownerStorageKey = '0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103';
    const [ownerAddress] = ethers_1.AbiCoder.defaultAbiCoder().decode(['address'], await provider.getStorage(proxyAddress, ownerStorageKey));
    return ownerAddress;
};
exports.getEIP1967ProxyAdminAddress = getEIP1967ProxyAdminAddress;
const getGasPriceOverrides = async (provider, signer, executionMode, overridden = {}) => {
    const [block, feeData, network] = await Promise.all([
        provider.getBlock('latest'),
        provider.getFeeData(),
        provider.getNetwork(),
    ]);
    if (!block) {
        throw new Error(`Unable to retrieve latest block.`);
    }
    if ((executionMode === constants_1.ExecutionMode.LocalNetworkCLI ||
        executionMode === constants_1.ExecutionMode.Platform) &&
        process.env.SPHINX_INTERNAL__DISABLE_HARDCODED_GAS_LIMIT !== 'true') {
        const maxGasLimit = (0, exports.getMaxGasLimit)(block.gasLimit, network.chainId);
        overridden.gasLimit = (maxGasLimit + block.gasLimit) / BigInt(2);
        return overridden;
    }
    const { maxFeePerGas, maxPriorityFeePerGas, gasPrice } = feeData;
    switch (Number(network.chainId)) {
        case 250:
            if (gasPrice !== null) {
                overridden.gasPrice = gasPrice;
                return overridden;
            }
        case 1442:
        case 1101:
            return overridden;
        case 59140:
            if (gasPrice !== null) {
                overridden.gasPrice = gasPrice * BigInt(10);
                return overridden;
            }
        case 59144:
            if (gasPrice !== null) {
                overridden.gasPrice = gasPrice;
            }
            return overridden;
        case 137:
            if (maxFeePerGas !== null && maxPriorityFeePerGas !== null) {
                overridden.maxFeePerGas = maxFeePerGas;
                overridden.maxPriorityFeePerGas = maxFeePerGas.toString();
            }
            return overridden;
        case 56:
        case 80001:
            overridden.nonce = await provider.getTransactionCount(await signer.getAddress(), 'latest');
            return overridden;
        case 66:
            return overridden;
        default:
            if (maxFeePerGas !== null && maxPriorityFeePerGas !== null) {
                overridden.maxFeePerGas = maxFeePerGas;
                overridden.maxPriorityFeePerGas = maxPriorityFeePerGas;
            }
            return overridden;
    }
};
exports.getGasPriceOverrides = getGasPriceOverrides;
const isUserContractKind = (contractKind) => {
    return types_1.userContractKinds.includes(contractKind);
};
exports.isUserContractKind = isUserContractKind;
const readBuildInfo = (buildInfoPath) => {
    const buildInfo = JSON.parse(fs.readFileSync(buildInfoPath, 'utf8'));
    return buildInfo;
};
exports.readBuildInfo = readBuildInfo;
const callWithTimeout = async (promise, timeout, errorMessage) => {
    let timeoutHandle;
    const timeoutPromise = new Promise((_resolve, reject) => {
        timeoutHandle = setTimeout(() => reject(new Error(errorMessage)), timeout);
    });
    return Promise.race([promise, timeoutPromise]).finally(() => {
        clearTimeout(timeoutHandle);
    });
};
exports.callWithTimeout = callWithTimeout;
const isDataHexString = (variable) => {
    return ethers_1.ethers.isHexString(variable) && variable.length % 2 === 0;
};
exports.isDataHexString = isDataHexString;
const isLiveNetwork = async (provider) => {
    try {
        await provider.send('hardhat_getAutomine', []);
    }
    catch (err) {
        return true;
    }
    return false;
};
exports.isLiveNetwork = isLiveNetwork;
const isFork = async (provider) => {
    try {
        const metadata = await provider.send(`hardhat_metadata`, []);
        return !!metadata.forkedNetwork;
    }
    catch {
        return false;
    }
};
exports.isFork = isFork;
const getImpersonatedSigner = async (address, provider) => {
    await provider.send('hardhat_impersonateAccount', [address]);
    if (provider instanceof provider_1.SphinxJsonRpcProvider) {
        return new ethers_1.JsonRpcSigner(provider, address);
    }
    else {
        return provider.getSigner(address);
    }
};
exports.getImpersonatedSigner = getImpersonatedSigner;
const stopImpersonatingAccount = async (address, provider) => {
    await provider.send('hardhat_stopImpersonatingAccount', [address]);
};
exports.stopImpersonatingAccount = stopImpersonatingAccount;
exports.execAsync = (0, util_1.promisify)(child_process_1.exec);
const getDuplicateElements = (arr) => {
    return [...new Set(arr.filter((e, i, a) => a.indexOf(e) !== i))];
};
exports.getDuplicateElements = getDuplicateElements;
const fetchSphinxManagedBaseUrl = () => {
    return process.env.SPHINX_MANAGED_BASE_URL
        ? process.env.SPHINX_MANAGED_BASE_URL
        : 'https://www.sphinx.dev';
};
exports.fetchSphinxManagedBaseUrl = fetchSphinxManagedBaseUrl;
const relayProposal = async (proposalRequest) => {
    try {
        await axios_1.default.post(`${(0, exports.fetchSphinxManagedBaseUrl)()}/api/propose`, proposalRequest);
    }
    catch (e) {
        if (e.response.status === 200) {
            return;
        }
        else if (e.response.status === 400) {
            throw new Error(`Malformed Request: ${e.response.data}`);
        }
        else if (e.response.status === 401) {
            throw new Error(`Unauthorized request. Please check your Sphinx API Key and organization ID are correct.`);
        }
        else if (e.response.status === 409) {
            throw new Error(`Unsupported network. Please report this to the developers.`);
        }
        else if (e.response.status === 500) {
            throw new Error(`Internal server error. Please report this to the developers.`);
        }
        else {
            throw new Error(`Unexpected response code. Please report this to the developers.`);
        }
    }
};
exports.relayProposal = relayProposal;
const storeDeploymentConfig = async (apiKey, orgId, configData) => {
    const response = await axios_1.default
        .post(`${(0, exports.fetchSphinxManagedBaseUrl)()}/api/getConfigUploadUrl`, {
        apiKey,
        orgId,
        hash: (0, ethers_1.keccak256)(ethers_1.ethers.toUtf8Bytes(configData.toString())),
        version: networks_1.COMPILER_CONFIG_VERSION,
    })
        .catch((err) => {
        if (err.response) {
            if (err.response.status === 400) {
                throw new Error('Malformed request storing compiler config, please report this to the developers');
            }
            else if (err.response.status === 401) {
                throw new Error(`Unauthorized, please check your API key and Org Id are correct`);
            }
            else {
                throw new Error(`Unexpected response code, please report this to the developers`);
            }
        }
        else {
            throw err;
        }
    });
    await axios_1.default.put(response.data.uploadUrl, configData, {
        headers: {
            'Content-Type': 'application/json',
        },
    });
    return response.data.configId;
};
exports.storeDeploymentConfig = storeDeploymentConfig;
const arraysEqual = (a, b) => {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (!(0, exports.equal)(a[i], b[i])) {
            return false;
        }
    }
    return true;
};
exports.arraysEqual = arraysEqual;
const userConfirmation = async (question) => {
    const confirmed = await (0, yesno_1.default)({
        question,
    });
    if (!confirmed) {
        console.error(`Denied by the user.`);
        process.exit(1);
    }
};
exports.userConfirmation = userConfirmation;
const getNetworkNameDirectory = (chainId, executionMode) => {
    const networkName = (0, networks_1.fetchNameForNetwork)(BigInt(chainId));
    if (executionMode === constants_1.ExecutionMode.LiveNetworkCLI ||
        executionMode === constants_1.ExecutionMode.Platform) {
        return networkName;
    }
    else if (executionMode === constants_1.ExecutionMode.LocalNetworkCLI) {
        return `${networkName}-local`;
    }
    else {
        throw new Error(`Unknown execution type.`);
    }
};
exports.getNetworkNameDirectory = getNetworkNameDirectory;
const getNetworkTag = (networkName, executionMode, chainId) => {
    if (executionMode === constants_1.ExecutionMode.Platform ||
        executionMode === constants_1.ExecutionMode.LiveNetworkCLI) {
        return networkName;
    }
    else if (contracts_1.SPHINX_NETWORKS.some((n) => n.name === networkName) &&
        !contracts_1.SPHINX_LOCAL_NETWORKS.some((n) => n.name === networkName)) {
        return `${networkName} (local)`;
    }
    else {
        return `local (chain ID: ${chainId})`;
    }
};
exports.getNetworkTag = getNetworkTag;
const isEventLog = (event) => {
    const eventLog = event;
    return (eventLog.args !== undefined &&
        eventLog.eventName !== undefined &&
        eventLog.eventSignature !== undefined &&
        eventLog.fragment !== undefined &&
        eventLog.interface !== undefined);
};
exports.isEventLog = isEventLog;
const sortHexStrings = (arr) => {
    const arrCopy = [...arr];
    return arrCopy.sort((a, b) => {
        const aBigInt = BigInt(a);
        const bBigInt = BigInt(b);
        return aBigInt < bBigInt ? -1 : aBigInt > bBigInt ? 1 : 0;
    });
};
exports.sortHexStrings = sortHexStrings;
const fromHexString = (inp) => {
    if (typeof inp === 'string' && inp.startsWith('0x')) {
        return Buffer.from(inp.slice(2), 'hex');
    }
    return Buffer.from(inp);
};
exports.fromHexString = fromHexString;
const toHexString = (inp) => {
    if (typeof inp === 'number') {
        return ethers_1.ethers.toBeHex(BigInt(inp));
    }
    else {
        return '0x' + (0, exports.fromHexString)(inp).toString('hex');
    }
};
exports.toHexString = toHexString;
const sleep = async (ms) => {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, ms);
    });
};
exports.sleep = sleep;
const isSupportedChainId = (chainId) => {
    return contracts_1.SPHINX_NETWORKS.some((n) => n.chainId === chainId);
};
exports.isSupportedChainId = isSupportedChainId;
const isSupportedNetworkName = (networkName) => {
    return (contracts_1.SPHINX_NETWORKS.some((n) => n.name === networkName) ||
        contracts_1.SPHINX_LOCAL_NETWORKS.some((n) => n.name === networkName));
};
exports.isSupportedNetworkName = isSupportedNetworkName;
const prettyFunctionCall = (referenceNameOrAddress, address, functionName, variables, chainId, value, spaceToIndentVariables = 2, spaceToIndentClosingParenthesis = 0) => {
    const stringified = JSON.stringify(variables, null, spaceToIndentVariables);
    const removedBrackets = stringified.substring(1, stringified.length - 1);
    const numSpacesForClosingParenthesis = removedBrackets.includes(`\n`)
        ? spaceToIndentClosingParenthesis
        : 0;
    const addedSpaceToClosingParenthesis = removedBrackets + ' '.repeat(numSpacesForClosingParenthesis);
    const addressTag = address !== '' ? `<${address}>` : '';
    const transferValue = value ?? 0;
    const valueString = BigInt(transferValue) > BigInt(0)
        ? `{ value: ${(0, ethers_1.formatUnits)(BigInt(transferValue), 'ether')} ether }`
        : '';
    const target = ethers_1.ethers.isAddress(referenceNameOrAddress)
        ? `(${referenceNameOrAddress})`
        : `${referenceNameOrAddress}${addressTag}`;
    return `${target}.${functionName}${valueString}(${addedSpaceToClosingParenthesis})`;
};
exports.prettyFunctionCall = prettyFunctionCall;
const prettyRawFunctionCall = (to, data) => {
    return `(${to}).${data}`;
};
exports.prettyRawFunctionCall = prettyRawFunctionCall;
const equal = (a, b) => {
    if (a === null || b === null) {
        return a === b;
    }
    else if ((Array.isArray(a) && !Array.isArray(b)) ||
        (!Array.isArray(a) && Array.isArray(b)) ||
        typeof a !== typeof b) {
        return false;
    }
    else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        else {
            for (let i = 0; i < a.length; i++) {
                if (!(0, exports.equal)(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
    }
    else if (typeof a === 'object' && typeof b === 'object') {
        if (Object.keys(a).length !== Object.keys(b).length) {
            return false;
        }
        else {
            for (const key of Object.keys(a)) {
                if (!(0, exports.equal)(a[key], b[key])) {
                    return false;
                }
            }
            return true;
        }
    }
    else if (typeof a === 'number' ||
        typeof a === 'boolean' ||
        typeof a === 'string') {
        return a === b;
    }
    else {
        throw new Error(`Unsupported type: ${typeof a}`);
    }
};
exports.equal = equal;
const elementsEqual = (ary) => {
    return ary.every((e) => (0, exports.equal)(e, ary[0]));
};
exports.elementsEqual = elementsEqual;
const displayDeploymentTable = (networkConfig) => {
    const deployments = {};
    let idx = 0;
    for (const input of networkConfig.actionInputs) {
        for (const { address, fullyQualifiedName } of input.contracts) {
            const contractName = fullyQualifiedName.split(':')[1];
            deployments[idx + 1] = {
                Contract: contractName,
                Address: address,
            };
            idx += 1;
        }
    }
    if (Object.keys(deployments).length > 0) {
        console.table(deployments);
    }
};
exports.displayDeploymentTable = displayDeploymentTable;
const spawnAsync = (cmd, args, env, inputData) => {
    return new Promise((resolve) => {
        const output = [];
        const error = [];
        const envVars = env ? { ...process.env, ...env } : process.env;
        const child = (0, child_process_1.spawn)(cmd, args, { env: envVars });
        child.stdout.on('data', (data) => {
            output.push(data);
        });
        child.stderr.on('data', (data) => {
            error.push(data);
        });
        if (inputData) {
            child.stdin.write(inputData);
            child.stdin.end();
        }
        child.on('close', (code) => {
            return resolve({
                stdout: Buffer.concat(output).toString(),
                stderr: Buffer.concat(error).toString(),
                code,
            });
        });
    });
};
exports.spawnAsync = spawnAsync;
const isString = (str) => {
    return typeof str === 'string';
};
exports.isString = isString;
const toSphinxTransaction = (actionInput) => {
    const { to, value, txData, gas, operation, requireSuccess } = actionInput;
    return {
        to,
        value,
        txData,
        gas,
        operation,
        requireSuccess,
    };
};
exports.toSphinxTransaction = toSphinxTransaction;
const getSphinxWalletsSortedByAddress = (numWallets, provider) => {
    const wallets = [];
    for (let i = 0; i < Number(numWallets); i++) {
        const privateKey = (0, exports.getSphinxWalletPrivateKey)(i);
        wallets.push(new ethers_1.ethers.Wallet(privateKey, provider));
    }
    const sortedWallets = wallets.sort((a, b) => Number(BigInt(a.address) - BigInt(b.address)));
    return sortedWallets;
};
exports.getSphinxWalletsSortedByAddress = getSphinxWalletsSortedByAddress;
const getSphinxWalletPrivateKey = (walletIndex) => {
    const coder = ethers_1.ethers.AbiCoder.defaultAbiCoder();
    return ethers_1.ethers.keccak256(coder.encode(['string', 'uint256'], ['sphinx.wallet', walletIndex]));
};
exports.getSphinxWalletPrivateKey = getSphinxWalletPrivateKey;
const addSphinxWalletsToGnosisSafeOwners = async (safeAddress, moduleAddress, executionMode, provider) => {
    const moduleSigner = await (0, exports.getImpersonatedSigner)(moduleAddress, provider);
    const safe = new ethers_1.ethers.Contract(safeAddress, contracts_1.GnosisSafeArtifact.abi, moduleSigner);
    const initialModuleBalance = await provider.getBalance(moduleAddress);
    await (0, exports.fundAccountMaxBalance)(moduleAddress, provider);
    const ownerThreshold = await safe.getThreshold();
    const sphinxWallets = (0, exports.getSphinxWalletsSortedByAddress)(ownerThreshold, provider);
    const iface = new ethers_1.ethers.Interface(contracts_1.GnosisSafeArtifact.abi);
    for (const wallet of sphinxWallets) {
        const data = iface.encodeFunctionData('addOwnerWithThreshold', [
            wallet.address,
            ownerThreshold,
        ]);
        await safe.execTransactionFromModule(safeAddress, 0, data, contracts_1.Operation.Call, await (0, exports.getGasPriceOverrides)(provider, moduleSigner, executionMode));
        if (!(await safe.isOwner(wallet.address))) {
            throw new Error(`Address is not owner. Should never happen.`);
        }
    }
    await (0, exports.setBalance)(moduleAddress, ethers_1.ethers.toBeHex(initialModuleBalance), provider);
    await provider.send('hardhat_stopImpersonatingAccount', [moduleAddress]);
};
exports.addSphinxWalletsToGnosisSafeOwners = addSphinxWalletsToGnosisSafeOwners;
const removeSphinxWalletsFromGnosisSafeOwners = async (sphinxWallets, safeAddress, moduleAddress, executionMode, provider) => {
    const moduleSigner = await (0, exports.getImpersonatedSigner)(moduleAddress, provider);
    const safe = new ethers_1.ethers.Contract(safeAddress, contracts_1.GnosisSafeArtifact.abi, moduleSigner);
    const initialModuleBalance = await provider.getBalance(moduleAddress);
    await (0, exports.fundAccountMaxBalance)(moduleAddress, provider);
    const ownerThreshold = Number(await safe.getThreshold());
    for (let i = 0; i < ownerThreshold - 1; i++) {
        await (0, exports.removeGnosisSafeOwnerViaSphinxModule)(sphinxWallets[i + 1].address, sphinxWallets[i].address, ownerThreshold, safe, executionMode, moduleSigner, provider);
    }
    await (0, exports.removeGnosisSafeOwnerViaSphinxModule)('0x' + '00'.repeat(19) + '01', sphinxWallets[ownerThreshold - 1].address, ownerThreshold, safe, executionMode, moduleSigner, provider);
    await (0, exports.setBalance)(moduleAddress, ethers_1.ethers.toBeHex(initialModuleBalance), provider);
    await provider.send('hardhat_stopImpersonatingAccount', [moduleAddress]);
};
exports.removeSphinxWalletsFromGnosisSafeOwners = removeSphinxWalletsFromGnosisSafeOwners;
const removeGnosisSafeOwnerViaSphinxModule = async (prevOwner, owner, ownerThreshold, safe, executionMode, moduleSigner, provider) => {
    const iface = new ethers_1.ethers.Interface(contracts_1.GnosisSafeArtifact.abi);
    const data = iface.encodeFunctionData('removeOwner', [
        prevOwner,
        owner,
        ownerThreshold,
    ]);
    await safe.execTransactionFromModule(safe.target, 0, data, contracts_1.Operation.Call, await (0, exports.getGasPriceOverrides)(provider, moduleSigner, executionMode));
    if (await safe.isOwner(owner)) {
        throw new Error(`Owner was not removed. Should never happen.`);
    }
};
exports.removeGnosisSafeOwnerViaSphinxModule = removeGnosisSafeOwnerViaSphinxModule;
const getApproveLeaf = (merkleTree, chainId) => {
    const leafWithProof = merkleTree.leavesWithProofs.find(({ leaf }) => leaf.chainId === chainId);
    if (!leafWithProof) {
        throw new Error(`Could not find 'APPROVE' leaf for chain ID: ${chainId}`);
    }
    return leafWithProof.leaf;
};
exports.getApproveLeaf = getApproveLeaf;
const getExecuteLeaves = (merkleTree, chainId) => {
    return merkleTree.leavesWithProofs
        .filter(({ leaf }) => leaf.chainId === chainId)
        .map((leafWithProof) => leafWithProof.leaf);
};
exports.getExecuteLeaves = getExecuteLeaves;
const findLeafWithProof = (merkleTree, leafType, chainId) => {
    const leafWithProof = merkleTree.leavesWithProofs.find(({ leaf }) => BigInt(leaf.chainId) === BigInt(chainId) &&
        BigInt(leaf.leafType) === BigInt(leafType));
    if (!leafWithProof) {
        throw new Error(`Could not find Merkle leaf with type ${(0, exports.stringifyLeafType)(leafType)} on chain ID: ${chainId}`);
    }
    return leafWithProof;
};
exports.findLeafWithProof = findLeafWithProof;
const stringifyLeafType = (leafType) => {
    if (leafType === contracts_1.SphinxLeafType.APPROVE) {
        return 'APPROVE';
    }
    else if (leafType === contracts_1.SphinxLeafType.EXECUTE) {
        return 'EXECUTE';
    }
    else if (leafType === contracts_1.SphinxLeafType.CANCEL) {
        return 'CANCEL';
    }
    else {
        throw new Error(`Unknown leaf type: ${leafType}`);
    }
};
exports.stringifyLeafType = stringifyLeafType;
const stringifyMerkleRootStatus = (status) => {
    switch (status) {
        case types_2.MerkleRootStatus.EMPTY:
            return 'EMPTY';
        case types_2.MerkleRootStatus.APPROVED:
            return 'APPROVED';
        case types_2.MerkleRootStatus.COMPLETED:
            return 'COMPLETED';
        case types_2.MerkleRootStatus.CANCELED:
            return 'CANCELED';
        case types_2.MerkleRootStatus.FAILED:
            return 'FAILED';
        default:
            throw new Error(`Unknown Merkle root status: ${status}`);
    }
};
exports.stringifyMerkleRootStatus = stringifyMerkleRootStatus;
const findStorageSlotKey = (storageLayout, varName) => {
    if (!storageLayout) {
        throw new Error(`Storage layout is undefined.`);
    }
    const storageObj = storageLayout.storage.find((s) => s.label === varName);
    if (!storageObj) {
        throw new Error(`Could not find storage slot key.`);
    }
    return storageObj.slot;
};
exports.findStorageSlotKey = findStorageSlotKey;
const assertValidProjectName = (input) => {
    const forbiddenChars = /[\/:*?"<>|]/;
    if (forbiddenChars.test(input)) {
        throw new Error('Project name contains forbidden characters: \\/:*?"<>|');
    }
    if (input.length === 0 || input.length > 255) {
        throw new Error('Project name length must be between 1 and 255 characters.');
    }
    const reservedNames = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    if (reservedNames.test(input)) {
        throw new Error('Project name uses a reserved name in Windows.');
    }
    if (input.length === 0) {
        throw new Error('Project name cannot be empty.');
    }
    if (input.includes(' ')) {
        throw new Error(`Project name cannot contain whitespace.`);
    }
};
exports.assertValidProjectName = assertValidProjectName;
const isSphinxTransaction = (obj) => {
    return (obj !== null &&
        typeof obj === 'object' &&
        typeof obj.to === 'string' &&
        typeof obj.value === 'string' &&
        typeof obj.txData === 'string' &&
        typeof obj.gas === 'string' &&
        obj.operation in contracts_1.Operation &&
        typeof obj.requireSuccess === 'boolean');
};
exports.isSphinxTransaction = isSphinxTransaction;
const signMerkleRoot = async (merkleRoot, wallet) => {
    const domain = {
        name: 'Sphinx',
        version: '1.0.0',
    };
    const types = { MerkleRoot: [{ name: 'root', type: 'bytes32' }] };
    const value = { root: merkleRoot };
    const signature = await wallet.signTypedData(domain, types, value);
    return signature;
};
exports.signMerkleRoot = signMerkleRoot;
const fundAccountMaxBalance = async (address, provider) => {
    await (0, exports.setBalance)(address, ethers_1.ethers.toBeHex(ethers_1.ethers.MaxUint256), provider);
};
exports.fundAccountMaxBalance = fundAccountMaxBalance;
const setBalance = async (address, balance, provider) => {
    await provider.send('hardhat_setBalance', [
        address,
        balance.replace('0x0', '0x'),
    ]);
};
exports.setBalance = setBalance;
const getMappingValueSlotKey = (mappingSlotKey, key) => {
    const padded = ethers_1.ethers.zeroPadValue(ethers_1.ethers.toBeHex(mappingSlotKey), 32);
    return ethers_1.ethers.keccak256(ethers_1.ethers.solidityPacked(['bytes32', 'bytes32'], [key, padded]));
};
exports.getMappingValueSlotKey = getMappingValueSlotKey;
const setManagedServiceRelayer = async (address, provider) => {
    const managedServiceAddress = (0, contracts_1.getManagedServiceAddress)();
    const accessControlRoleSlotKey = (0, exports.findStorageSlotKey)(contracts_1.ManagedServiceArtifact.storageLayout, '_roles');
    const roleSlotKey = (0, exports.getMappingValueSlotKey)(accessControlRoleSlotKey, constants_1.RELAYER_ROLE);
    const memberSlotKey = (0, exports.getMappingValueSlotKey)(roleSlotKey, ethers_1.ethers.zeroPadValue(ethers_1.ethers.toBeHex(address), 32));
    await provider.send('hardhat_setStorageAt', [
        managedServiceAddress,
        memberSlotKey,
        '0x0000000000000000000000000000000000000000000000000000000000000001',
    ]);
};
exports.setManagedServiceRelayer = setManagedServiceRelayer;
const getReadableActions = (actionInputs, chainId) => {
    return actionInputs.map((action) => {
        const { referenceName, functionName, variables, address, value } = action.decodedAction;
        const actionStr = (0, exports.prettyFunctionCall)(referenceName, address, functionName, variables, chainId, value, 5, 3);
        return {
            reason: actionStr,
            actionIndex: action.index,
        };
    });
};
exports.getReadableActions = getReadableActions;
const getCreate3Address = (deployer, salt) => {
    const proxyBytecode = '0x67363d3d37363d34f03d5260086018f3';
    const proxyAddress = ethers_1.ethers.getCreate2Address(deployer, salt, ethers_1.ethers.keccak256(proxyBytecode));
    const addressHash = ethers_1.ethers.keccak256(ethers_1.ethers.concat(['0xd694', proxyAddress, '0x01']));
    const last20Bytes = ethers_1.ethers.dataSlice(addressHash, 12);
    return ethers_1.ethers.getAddress(last20Bytes);
};
exports.getCreate3Address = getCreate3Address;
const toSphinxLeafWithProofArray = (input) => {
    return input.map((item) => ({
        leaf: {
            ...item.leaf,
            chainId: BigInt(item.leaf.chainId),
            index: BigInt(item.leaf.index),
        },
        proof: item.proof,
    }));
};
exports.toSphinxLeafWithProofArray = toSphinxLeafWithProofArray;
const getCreate3Salt = (referenceName, userSalt) => {
    return ethers_1.ethers.keccak256(ethers_1.ethers.AbiCoder.defaultAbiCoder().encode(['string', 'bytes32'], [referenceName, userSalt]));
};
exports.getCreate3Salt = getCreate3Salt;
const getMaxGasLimit = (blockGasLimit, chainId) => {
    if ((0, networks_1.shouldUseHigherMaxGasLimit)(chainId)) {
        return (blockGasLimit * BigInt(8)) / BigInt(10);
    }
    return blockGasLimit / BigInt(2);
};
exports.getMaxGasLimit = getMaxGasLimit;
const formatSolcLongVersion = (solcLongVersion) => {
    const match = solcLongVersion.match(/(\d+\.\d+\.\d+\+commit\.[a-f0-9]+)/);
    return match ? match[0] : solcLongVersion;
};
exports.formatSolcLongVersion = formatSolcLongVersion;
const stripLeadingZero = (hexString) => {
    return hexString.replace('0x0', '0x');
};
exports.stripLeadingZero = stripLeadingZero;
const getBytesLength = (hexString) => {
    return (0, contracts_1.remove0x)(hexString).length / 2;
};
exports.getBytesLength = getBytesLength;
const zeroOutLibraryReferences = (bytecode, linkReferences) => {
    const replacer = (0, contracts_1.remove0x)(ethers_1.ethers.ZeroAddress);
    let modifiedBytecode = bytecode;
    for (const references of Object.values(linkReferences)) {
        for (const libraryReferences of Object.values(references)) {
            for (const ref of libraryReferences) {
                const start = 2 + ref.start * 2;
                modifiedBytecode =
                    modifiedBytecode.substring(0, start) +
                        replacer +
                        modifiedBytecode.substring(start + ref.length * 2);
            }
        }
    }
    return modifiedBytecode;
};
exports.zeroOutLibraryReferences = zeroOutLibraryReferences;
const isDefined = (value) => value !== undefined;
exports.isDefined = isDefined;
const getAbiEncodedConstructorArgs = (initCodeWithArgs, artifactBytecode) => {
    return ethers_1.ethers.dataSlice(initCodeWithArgs, ethers_1.ethers.dataLength(artifactBytecode));
};
exports.getAbiEncodedConstructorArgs = getAbiEncodedConstructorArgs;
const decodeCall = (iface, data) => {
    if ((0, exports.getBytesLength)(data) >= 4) {
        const selector = ethers_1.ethers.dataSlice(data, 0, 4);
        const fragment = iface.fragments
            .filter(ethers_1.FunctionFragment.isFragment)
            .find((frag) => frag.selector === selector);
        if (fragment) {
            const variablesResult = iface.decodeFunctionData(fragment, data);
            const variables = (0, contracts_1.recursivelyConvertResult)(fragment.inputs, variablesResult);
            return { functionName: fragment.name, variables };
        }
    }
    return undefined;
};
exports.decodeCall = decodeCall;
const encodeCreateCall = (value, initCodeWithArgs) => {
    const iface = new ethers_1.ethers.Interface(contracts_1.CreateCallArtifact.abi);
    return iface.encodeFunctionData('performCreate', [
        BigInt(value),
        initCodeWithArgs,
    ]);
};
exports.encodeCreateCall = encodeCreateCall;
const decodeDeterministicDeploymentProxyData = (saltAndInitCodeWithArgs) => {
    const salt = ethers_1.ethers.dataSlice(saltAndInitCodeWithArgs, 0, 32);
    const initCodeWithArgs = ethers_1.ethers.dataSlice(saltAndInitCodeWithArgs, 32);
    const create2Address = ethers_1.ethers.getCreate2Address(contracts_1.DETERMINISTIC_DEPLOYMENT_PROXY_ADDRESS, salt, ethers_1.ethers.keccak256(initCodeWithArgs));
    return { salt, initCodeWithArgs, create2Address };
};
exports.decodeDeterministicDeploymentProxyData = decodeDeterministicDeploymentProxyData;
const isCreate2ActionInput = (action) => {
    const create2 = action;
    return (create2 !== null &&
        typeof create2 === 'object' &&
        create2.actionType === types_1.ActionInputType.CREATE2 &&
        typeof create2.create2Address === 'string' &&
        typeof create2.initCodeWithArgs === 'string' &&
        Array.isArray(create2.contracts) &&
        typeof create2.decodedAction === 'object' &&
        typeof create2.index === 'string' &&
        typeof create2.to === 'string' &&
        typeof create2.value === 'string' &&
        typeof create2.txData === 'string' &&
        typeof create2.gas === 'string' &&
        create2.operation === contracts_1.Operation.Call &&
        typeof create2.requireSuccess === 'boolean');
};
exports.isCreate2ActionInput = isCreate2ActionInput;
const isCreateActionInput = (action) => {
    const create = action;
    return (create !== null &&
        typeof create === 'object' &&
        create.actionType === types_1.ActionInputType.CREATE &&
        typeof create.contractAddress === 'string' &&
        typeof create.initCodeWithArgs === 'string' &&
        Array.isArray(create.contracts) &&
        typeof create.decodedAction === 'object' &&
        typeof create.index === 'string' &&
        typeof create.to === 'string' &&
        typeof create.value === 'string' &&
        typeof create.txData === 'string' &&
        typeof create.gas === 'string' &&
        create.operation === contracts_1.Operation.DelegateCall &&
        typeof create.requireSuccess === 'boolean');
};
exports.isCreateActionInput = isCreateActionInput;
const isFile = (path) => {
    return fs.existsSync(path) && fs.statSync(path).isFile();
};
exports.isFile = isFile;
const isNormalizedAddress = (addr) => {
    return ethers_1.ethers.getAddress(addr) === addr;
};
exports.isNormalizedAddress = isNormalizedAddress;
const fetchNetworkConfigFromDeploymentConfig = (chainId, deploymentConfig) => {
    const networkConfig = deploymentConfig.networkConfigs.find((config) => BigInt(config.chainId) === chainId);
    if (!networkConfig) {
        throw new Error('Failed to find parsed config for target network. This is a bug, please report it to the developers.');
    }
    return networkConfig;
};
exports.fetchNetworkConfigFromDeploymentConfig = fetchNetworkConfigFromDeploymentConfig;
const isDirectory = (path) => (0, fs_1.existsSync)(path) && fs.statSync(path).isDirectory();
const readDeploymentArtifactsForNetwork = (projectName, chainId, executionMode) => {
    const networkArtifacts = {
        contractDeploymentArtifacts: {},
        executionArtifacts: {},
    };
    const networkArtifactDirPath = (0, path_1.join)(`deployments`, projectName, (0, exports.getNetworkNameDirectory)(chainId.toString(), executionMode));
    if (!isDirectory(networkArtifactDirPath)) {
        return networkArtifacts;
    }
    const contractArtifactFileNames = fs
        .readdirSync(networkArtifactDirPath)
        .filter((fileName) => fileName.endsWith('.json'));
    for (const fileName of contractArtifactFileNames) {
        const filePath = (0, path_1.join)(networkArtifactDirPath, fileName);
        const artifact = JSON.parse(fs.readFileSync(filePath, 'utf8'));
        if ((0, artifacts_1.isContractDeploymentArtifact)(artifact)) {
            networkArtifacts.contractDeploymentArtifacts[fileName] = artifact;
        }
    }
    const executionArtifactFilePath = (0, path_1.join)(networkArtifactDirPath, `execution`);
    if (!isDirectory(executionArtifactFilePath)) {
        return networkArtifacts;
    }
    const executionArtifactFileNames = fs
        .readdirSync(executionArtifactFilePath)
        .filter((fileName) => fileName.endsWith('.json'));
    for (const fileName of executionArtifactFileNames) {
        const filePath = (0, path_1.join)(executionArtifactFilePath, fileName);
        const artifact = JSON.parse(fs.readFileSync(filePath, 'utf8'));
        if ((0, artifacts_1.isExecutionArtifact)(artifact)) {
            networkArtifacts.executionArtifacts[fileName] = artifact;
        }
    }
    return networkArtifacts;
};
exports.readDeploymentArtifactsForNetwork = readDeploymentArtifactsForNetwork;
const isArrayMixed = (arr) => new Set(arr).size > 1;
exports.isArrayMixed = isArrayMixed;
const getContractAddressesFromNetworkConfig = (networkConfig) => {
    const unlabeledAddresses = networkConfig.unlabeledContracts.map((ct) => ct.address);
    const labeledAddresses = networkConfig.actionInputs
        .flatMap((actions) => actions.contracts)
        .map((ct) => ct.address);
    return unlabeledAddresses.concat(labeledAddresses);
};
exports.getContractAddressesFromNetworkConfig = getContractAddressesFromNetworkConfig;
const hasParentheses = (str) => {
    return /\(.*\)/.test(str);
};
exports.hasParentheses = hasParentheses;
const trimQuotes = (str) => {
    return str.replace(/^['"]+|['"]+$/g, '');
};
exports.trimQuotes = trimQuotes;
const isPublicAsyncMethod = (obj, prop) => {
    let currentObj = obj;
    while (currentObj && currentObj !== Object.prototype) {
        const propValue = currentObj[prop];
        if (typeof propValue === 'function' &&
            propValue.constructor.name === 'AsyncFunction' &&
            typeof prop === 'string' &&
            !prop.startsWith('_')) {
            return true;
        }
        currentObj = Object.getPrototypeOf(currentObj);
    }
    return false;
};
exports.isPublicAsyncMethod = isPublicAsyncMethod;
exports.sphinxCoreUtils = { sleep: exports.sleep, callWithTimeout: exports.callWithTimeout, isPublicAsyncMethod: exports.isPublicAsyncMethod };
//# sourceMappingURL=utils.js.map